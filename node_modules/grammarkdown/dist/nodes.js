"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetaElementBase = exports.Production = exports.SourceElementBase = exports.ParameterList = exports.Parameter = exports.OneOfList = exports.RightHandSideList = exports.RightHandSide = exports.ProductionBodyBase = exports.LinkReference = exports.SymbolSpan = exports.ArgumentList = exports.Argument = exports.ProseFragmentLiteral = exports.InvalidAssertion = exports.ProseAssertion = exports.NoSymbolHereAssertion = exports.LexicalGoalAssertion = exports.LookaheadAssertion = exports.EmptyAssertion = exports.AssertionBase = exports.Nonterminal = exports.Terminal = exports.OptionalSymbolBase = exports.PrimarySymbolBase = exports.InvalidSymbol = exports.OneOfSymbol = exports.Prose = exports.ButNotSymbol = exports.UnicodeCharacterRange = exports.PlaceholderSymbol = exports.LexicalSymbolBase = exports.Constraints = exports.SymbolSet = exports.Identifier = exports.TerminalLiteral = exports.UnicodeCharacterLiteral = exports.NumberLiteral = exports.StringLiteral = exports.Token = exports.HtmlCloseTagTrivia = exports.HtmlOpenTagTrivia = exports.HtmlTagTriviaBase = exports.HtmlCommentTrivia = exports.HtmlTriviaBase = exports.MultiLineCommentTrivia = exports.SingleLineCommentTrivia = exports.CommentTriviaBase = exports.TriviaBase = exports.Node = void 0;
exports.forEachChild = exports.SourceFile = exports.Line = exports.Define = exports.Import = void 0;
const core_1 = require("./core");
const diagnostics_1 = require("./diagnostics");
const nodeInternal_1 = require("./nodeInternal");
const scanner_1 = require("./scanner");
const tokens_1 = require("./tokens");
/** {@docCategory Nodes} */
class Node {
    constructor(kind) {
        this._pos = 0;
        this._end = 0;
        this.kind = kind;
    }
    get pos() { return this._pos; }
    ;
    get end() { return this._end; }
    ;
    /**
     * Leading trivia is trivia that belongs to the beginning of the node:
     * - An HTML close tag trivia, or any trivia preceding an HTML close tag trivia, is not leading trivia of the node.
     * - An HTML open tag trivia, and any trivia following an HTML open tag trivia, is leading trivia of the node.
     * - If the node has a preceding line break, then
     *   - Any other non-HTML tag trivia on the same line as the node that precedes the node is leading trivia of the node.
     *   - Any other non-HTML tag trivia on a line that precedes the node, but not preceding a blank line, is leading trivia of the node.
     * - Otherwise,
     *   - Any other non-HTML tag trivia on the same line as the node that precedes the node is leading trivia, if there is no whitespace between
     *     that trivia and the node.
     */
    get leadingTrivia() { return this._leadingTrivia; }
    /**
     * Trailing trivia is trivia that belongs to the end of the node:
     * - An HTML open tag trivia, or any trivia following an HTML open tag trivia, is not trailing trivia of the node.
     * - An HTML close tag trivia, and any trivia preceding an HTML close tag trivia, is trailing trivia of the node.
     * - If the node has a trailing line break, then
     *   - Any other non-HTML tag trivia on the same line as the node that follows the node is trailing trivia of the node.
     *   - Any other non-HTML tag trivia on a line that follows the node, but not following a blank line, is trailing trivia of the node.
     * - Otherwise,
     *   - Any other non-HTML tag trivia on the same line as the node that follows the node is trailing trivia, if there is no whitespace between
     *     that trivia and the node.
     */
    get trailingTrivia() { return this._trailingTrivia; }
    /**
     * Detached trivia is any trivia that occurs prior to the node that is not the leading or trailing trivia of this
     * or any other node.
     */
    get detachedTrivia() { return this._detachedTrivia; }
    /** @deprecated Use {@link leadingTrivia} or {@link detachedTrivia} instead. */
    get leadingHtmlTrivia() { var _a; return this._leadingHtmlTrivia || (this._leadingHtmlTrivia = (_a = this._leadingTrivia) === null || _a === void 0 ? void 0 : _a.filter((trivia) => (0, tokens_1.isHtmlTriviaKind)(trivia.kind))); }
    /** @deprecated Use {@link trailingTrivia} instead. */
    get trailingHtmlTrivia() { var _a; return this._trailingHtmlTrivia || (this._trailingHtmlTrivia = (_a = this._trailingTrivia) === null || _a === void 0 ? void 0 : _a.filter((trivia) => (0, tokens_1.isHtmlTriviaKind)(trivia.kind))); }
    getStart(sourceFile) { return sourceFile ? (0, scanner_1.skipTrivia)(sourceFile.text, this.pos, this.end) : this.pos; }
    getEnd() { return this.end; }
    getWidth(sourceFile) { return this.getEnd() - this.getStart(sourceFile); }
    getFullStart() { return this.pos; }
    getFullWidth() { return this.getEnd() - this.getFullStart(); }
    getText(sourceFile) { return sourceFile.text.slice(this.getStart(sourceFile), this.getEnd()); }
    getFullText(sourceFile) { return sourceFile.text.slice(this.getFullStart(), this.getEnd()); }
    get firstChild() { return undefined; }
    get lastChild() { return undefined; }
    forEachChild(_cbNode) { return undefined; }
    children() { return core_1.emptyIterable; }
    get edgeCount() { return 0; }
    edgeName(_offset) { return undefined; }
    edgeValue(_offset) { return undefined; }
    accept(visitor) { return visitor.visitExtension(this); }
}
exports.Node = Node;
(() => {
    (0, nodeInternal_1.setNodeAccessor)({
        setTextRange(node, pos, end) {
            node._pos = pos;
            node._end = end;
            return node;
        },
        setDetachedTrivia(node, trivia) {
            node._detachedTrivia = trivia;
        },
        setLeadingTrivia(node, trivia) {
            node._leadingTrivia = trivia;
            node._leadingHtmlTrivia = undefined;
        },
        setTrailingTrivia(node, trivia) {
            node._trailingTrivia = trivia;
            node._trailingHtmlTrivia = undefined;
        },
        edgeCount(node) { return node.edgeCount; },
        edgeName(node, offset) { return node.edgeName(offset); },
        edgeValue(node, offset) { return node.edgeValue(offset); },
        accept(node, visitor) { return node.accept(visitor); },
    });
})();
/** {@docCategory Nodes} */
class TriviaBase extends Node {
    constructor() {
        super(...arguments);
        this._hasPrecedingLineTerminator = false;
        this._hasPrecedingBlankLine = false;
        this._hasPrecedingWhiteSpace = false;
        this._hasFollowingLineTerminator = false;
        this._hasFollowingBlankLine = false;
        this._hasFollowingWhiteSpace = false;
    }
    get hasPrecedingLineTerminator() { return this._hasPrecedingLineTerminator; }
    get hasPrecedingBlankLine() { return this._hasPrecedingBlankLine; }
    get hasPrecedingWhiteSpace() { return this._hasPrecedingWhiteSpace; }
    get hasFollowingLineTerminator() { return this._hasFollowingLineTerminator; }
    get hasFollowingBlankLine() { return this._hasFollowingBlankLine; }
    get hasFollowingWhiteSpace() { return this._hasFollowingWhiteSpace; }
}
exports.TriviaBase = TriviaBase;
(() => {
    (0, nodeInternal_1.setTriviaAccessor)({
        setPrecedingFields(node, hasPrecedingLineTerminator, hasPrecedingBlankLine, hasPrecedingWhiteSpace) {
            node._hasPrecedingLineTerminator = hasPrecedingLineTerminator;
            node._hasPrecedingBlankLine = hasPrecedingBlankLine;
            node._hasPrecedingWhiteSpace = hasPrecedingWhiteSpace;
        },
        setFollowingFields(node, hasFollowingLineTerminator, hasFollowingBlankLine, hasFollowingWhiteSpace) {
            node._hasFollowingLineTerminator = hasFollowingLineTerminator;
            node._hasFollowingBlankLine = hasFollowingBlankLine;
            node._hasFollowingWhiteSpace = hasFollowingWhiteSpace;
        }
    });
})();
/** {@docCategory Nodes} */
class CommentTriviaBase extends TriviaBase {
}
exports.CommentTriviaBase = CommentTriviaBase;
/**
 * Represent a single-line comment trivia token.
 * ```grammarkdown
 * // comment
 * ```
 * {@docCategory Nodes}
 */
class SingleLineCommentTrivia extends CommentTriviaBase {
    constructor() {
        super(tokens_1.SyntaxKind.SingleLineCommentTrivia);
    }
}
exports.SingleLineCommentTrivia = SingleLineCommentTrivia;
/**
 * Represents a multi-line comment trivia token.
 * {@docCategory Nodes}
 */
class MultiLineCommentTrivia extends CommentTriviaBase {
    constructor() {
        super(tokens_1.SyntaxKind.MultiLineCommentTrivia);
    }
}
exports.MultiLineCommentTrivia = MultiLineCommentTrivia;
/** {@docCategory Nodes} */
class HtmlTriviaBase extends TriviaBase {
}
exports.HtmlTriviaBase = HtmlTriviaBase;
/**
 * Represents an HTML comment trivia token:
 * ```grammarkdown
 * Production ::
 *   <!--before-->Nonterminal
 * ```
 * {@docCategory Nodes}
 */
class HtmlCommentTrivia extends HtmlTriviaBase {
    constructor() {
        super(tokens_1.SyntaxKind.HtmlCommentTrivia);
    }
}
exports.HtmlCommentTrivia = HtmlCommentTrivia;
/** {@docCategory Nodes} */
class HtmlTagTriviaBase extends HtmlTriviaBase {
    constructor(kind, tagName) {
        super(kind);
        this.tagName = tagName;
    }
}
exports.HtmlTagTriviaBase = HtmlTagTriviaBase;
/**
 * Represents an HTML open-tag trivia token:
 * ```grammarkdown
 * Production ::
 *   <ins>Inserted</ins>
 *   <del>Deleted</del>
 * ```
 * {@docCategory Nodes}
 */
class HtmlOpenTagTrivia extends HtmlTagTriviaBase {
    constructor(tagName) {
        super(tokens_1.SyntaxKind.HtmlOpenTagTrivia, tagName);
    }
}
exports.HtmlOpenTagTrivia = HtmlOpenTagTrivia;
/**
 * Represents an HTML close-tag trivia token:
 * ```grammarkdown
 * Production ::
 *   <ins>Inserted</ins>
 *   <del>Deleted</del>
 * ```
 * {@docCategory Nodes}
 */
class HtmlCloseTagTrivia extends HtmlTagTriviaBase {
    constructor(tagName) {
        super(tokens_1.SyntaxKind.HtmlCloseTagTrivia, tagName);
    }
}
exports.HtmlCloseTagTrivia = HtmlCloseTagTrivia;
/**
 * Represents a token such as a keyword or operator.
 * {@docCategory Nodes}
 */
class Token extends Node {
    accept(visitor) { return visitor.visitToken(this); }
}
exports.Token = Token;
/**
 * Represents a single- or double-quoted string literal (used by `@import` and `@line`)
 * ```grammarkdown
 * @import "file"
 * ```
 * {@docCategory Nodes}
 */
class StringLiteral extends Node {
    constructor(text) {
        super(tokens_1.SyntaxKind.StringLiteral);
        this.text = text;
    }
    accept(visitor) { return visitor.visitStringLiteral(this); }
}
exports.StringLiteral = StringLiteral;
/**
 * Represents a number literal (used by `@line`)
 * ```grammarkdown
 * @line 500
 * Production :: Nonterminal
 * ```
 * {@docCategory Nodes}
 */
class NumberLiteral extends Node {
    constructor(text) {
        super(tokens_1.SyntaxKind.NumberLiteral);
        this.text = text;
    }
    accept(visitor) { return visitor.visitNumberLiteral(this); }
}
exports.NumberLiteral = NumberLiteral;
/**
 * Represents a Unicode character literal in one of two forms:
 * ```grammarkdown
 * <TAB>
 * U+0000
 * ```
 * {@docCategory Nodes}
 */
class UnicodeCharacterLiteral extends Node {
    constructor(text) {
        super(tokens_1.SyntaxKind.UnicodeCharacterLiteral);
        this.text = text;
    }
    accept(visitor) { return visitor.visitUnicodeCharacterLiteral(this); }
}
exports.UnicodeCharacterLiteral = UnicodeCharacterLiteral;
/**
 * Represents a terminal token in the grammar.
 * ```grammarkdown
 * `yield`
 * ```
 * {@docCategory Nodes}
 */
class TerminalLiteral extends Node {
    constructor(text) {
        super(tokens_1.SyntaxKind.TerminalLiteral);
        this.text = text;
    }
    accept(visitor) { return visitor.visitTerminalLiteral(this); }
}
exports.TerminalLiteral = TerminalLiteral;
/**
 * Represents an identifier such as a Production or Parameter.
 * {@docCategory Nodes}
 */
class Identifier extends Node {
    constructor(text) {
        super(tokens_1.SyntaxKind.Identifier);
        this.text = text;
    }
    accept(visitor) { return visitor.visitIdentifier(this); }
}
exports.Identifier = Identifier;
/**
 * Represents a set of symbols in a `lookahead` assertion.
 * ```grammarkdown
 * [lookahead ∈ { `a`, `b` }]
 * ```
 * {@docCategory Nodes}
 */
class SymbolSet extends Node {
    constructor(openBraceToken, elements, closeBraceToken) {
        super(tokens_1.SyntaxKind.SymbolSet);
        this.openBraceToken = openBraceToken;
        this.elements = elements;
        this.closeBraceToken = closeBraceToken;
    }
    get firstChild() { return this.openBraceToken; }
    get lastChild() { return this.closeBraceToken || (0, core_1.last)(this.elements) || this.openBraceToken; }
    forEachChild(cbNode) {
        return cbNode(this.openBraceToken)
            || (this.elements && (0, core_1.forEach)(this.elements, cbNode))
            || (this.closeBraceToken && cbNode(this.closeBraceToken));
    }
    *children() {
        yield this.openBraceToken;
        if (this.elements)
            yield* this.elements;
        if (this.closeBraceToken)
            yield this.closeBraceToken;
    }
    update(elements) {
        return elements !== this.elements
            ? setTextRange(new SymbolSet(this.openBraceToken, elements, this.closeBraceToken), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "openBraceToken";
            case 1: return "elements";
            case 2: return "closeBraceToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.openBraceToken;
            case 1: return this.elements;
            case 2: return this.closeBraceToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitSymbolSet(this); }
}
exports.SymbolSet = SymbolSet;
/**
 * Represents a set of constraints for a right-hand-side of a Production.
 * ```grammarkdown
 * Production[A] ::
 *   [+A] A
 *   [~A] B
 * ```
 * {@docCategory Nodes}
 */
class Constraints extends Node {
    constructor(openBracketToken, elements, closeBracketToken) {
        super(tokens_1.SyntaxKind.Constraints);
        this.openBracketToken = openBracketToken;
        this.elements = elements;
        this.closeBracketToken = closeBracketToken;
    }
    get firstChild() { return this.openBracketToken; }
    get lastChild() { return this.closeBracketToken || (0, core_1.last)(this.elements); }
    forEachChild(cbNode) {
        return cbNode(this.openBracketToken)
            || (this.elements && (0, core_1.forEach)(this.elements, cbNode))
            || (this.closeBracketToken && cbNode(this.closeBracketToken));
    }
    *children() {
        yield this.openBracketToken;
        if (this.elements)
            yield* this.elements;
        if (this.closeBracketToken)
            yield this.closeBracketToken;
    }
    update(elements) {
        return elements !== this.elements
            ? setTextRange(new Constraints(this.openBracketToken, elements, this.closeBracketToken), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "openBracketToken";
            case 1: return "elements";
            case 2: return "closeBracketToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.openBracketToken;
            case 1: return this.elements;
            case 2: return this.closeBracketToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitConstraints(this); }
}
exports.Constraints = Constraints;
//
// Symbols
//
/** {@docCategory Nodes} */
class LexicalSymbolBase extends Node {
}
exports.LexicalSymbolBase = LexicalSymbolBase;
/**
 * Represents a placeholder symbol (`@`) used in some grammars.
 * {@docCategory Nodes}
 */
class PlaceholderSymbol extends LexicalSymbolBase {
    constructor(placeholderToken) {
        super(tokens_1.SyntaxKind.PlaceholderSymbol);
        this.placeholderToken = placeholderToken;
    }
    get firstChild() { return this.placeholderToken; }
    get lastChild() { return this.placeholderToken; }
    forEachChild(cbNode) {
        return cbNode(this.placeholderToken);
    }
    *children() {
        yield this.placeholderToken;
    }
    get edgeCount() { return 1; }
    edgeName(offset) { return offset === 0 ? "placeholderToken" : undefined; }
    edgeValue(offset) { return offset === 0 ? this.placeholderToken : undefined; }
    accept(visitor) { return visitor.visitPlaceholderSymbol(this); }
}
exports.PlaceholderSymbol = PlaceholderSymbol;
/**
 * Represents a range of unicode characters.
 * ```grammarkdown
 * U+0000 through U+001F
 * ```
 * {@docCategory Nodes}
 */
class UnicodeCharacterRange extends LexicalSymbolBase {
    constructor(left, throughKeyword, right) {
        super(tokens_1.SyntaxKind.UnicodeCharacterRange);
        this.left = left;
        this.throughKeyword = throughKeyword;
        this.right = right;
    }
    get firstChild() { return this.left; }
    get lastChild() { return this.right; }
    forEachChild(cbNode) {
        return cbNode(this.left)
            || cbNode(this.throughKeyword)
            || cbNode(this.right);
    }
    *children() {
        yield this.left;
        yield this.throughKeyword;
        yield this.right;
    }
    update(left, right) {
        return left !== this.left || right !== this.right
            ? setTextRange(new UnicodeCharacterRange(left, this.throughKeyword, right), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "left";
            case 1: return "throughKeyword";
            case 2: return "right";
        }
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.left;
            case 1: return this.throughKeyword;
            case 2: return this.right;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitUnicodeCharacterRange(this); }
}
exports.UnicodeCharacterRange = UnicodeCharacterRange;
/**
 * The \`but not\` operator allows you to reference a *Nonterminal* on the left, excluding some part of that production.
 * ```grammarkdown
 * A but not B
 * ```
 * {@docCategory Nodes}
 */
class ButNotSymbol extends LexicalSymbolBase {
    constructor(left, butKeyword, notKeyword, right) {
        super(tokens_1.SyntaxKind.ButNotSymbol);
        this.left = left;
        this.butKeyword = butKeyword;
        this.notKeyword = notKeyword;
        this.right = right;
    }
    get firstChild() { return this.left; }
    get lastChild() { return this.right || this.notKeyword || this.butKeyword || this.left; }
    forEachChild(cbNode) {
        return cbNode(this.left)
            || (this.butKeyword && cbNode(this.butKeyword))
            || (this.notKeyword && cbNode(this.notKeyword))
            || (this.right && cbNode(this.right));
    }
    *children() {
        yield this.left;
        if (this.butKeyword)
            yield this.butKeyword;
        if (this.notKeyword)
            yield this.notKeyword;
        if (this.right)
            yield this.right;
    }
    update(left, right) {
        return left !== this.left || right !== this.right
            ? setTextRange(new ButNotSymbol(left, this.butKeyword, this.notKeyword, right), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 4; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "left";
            case 1: return "butKeyword";
            case 2: return "notKeyword";
            case 3: return "right";
        }
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.left;
            case 1: return this.butKeyword;
            case 2: return this.notKeyword;
            case 3: return this.right;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitButNotSymbol(this); }
}
exports.ButNotSymbol = ButNotSymbol;
/**
 * Represents a section of Prose, which indicates handling of syntax outside the scope of the Grammarkdown parser.
 * ```grammarkdown
 * > This is a section of Prose with |Nonterminals| and `terminals`
 * ```
 * {@docCategory Nodes}
 */
class Prose extends LexicalSymbolBase {
    constructor(greaterThanToken, fragments) {
        super(tokens_1.SyntaxKind.Prose);
        this.greaterThanToken = greaterThanToken;
        this.fragments = fragments;
    }
    get firstChild() { return this.greaterThanToken; }
    get lastChild() { return (0, core_1.last)(this.fragments) || this.greaterThanToken; }
    forEachChild(cbNode) {
        return cbNode(this.greaterThanToken)
            || (this.fragments && (0, core_1.forEach)(this.fragments, cbNode));
    }
    *children() {
        yield this.greaterThanToken;
        if (this.fragments)
            yield* this.fragments;
    }
    update(fragments) {
        return fragments !== this.fragments
            ? setTextRange(new Prose(this.greaterThanToken, fragments), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 2; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "greaterThanToken";
            case 1: return "fragments";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.greaterThanToken;
            case 1: return this.fragments;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitProse(this); }
}
exports.Prose = Prose;
/**
 * Represents a set of symbols used to restrict a `but not` operator.
 * ```grammarkdown
 * A but not one of `a` or `b`
 * ```
 * {@docCategory Nodes}
 */
class OneOfSymbol extends LexicalSymbolBase {
    constructor(oneKeyword, ofKeyword, symbols) {
        super(tokens_1.SyntaxKind.OneOfSymbol);
        this.oneKeyword = oneKeyword;
        this.ofKeyword = ofKeyword;
        this.symbols = symbols;
    }
    get firstChild() { return this.oneKeyword; }
    get lastChild() { return (0, core_1.last)(this.symbols) || this.ofKeyword || this.oneKeyword; }
    forEachChild(cbNode) {
        return cbNode(this.oneKeyword)
            || (this.ofKeyword && cbNode(this.ofKeyword))
            || (this.symbols && (0, core_1.forEach)(this.symbols, cbNode));
    }
    *children() {
        yield this.oneKeyword;
        if (this.ofKeyword)
            yield this.ofKeyword;
        if (this.symbols)
            yield* this.symbols;
    }
    update(symbols) {
        return symbols !== this.symbols
            ? setTextRange(new OneOfSymbol(this.oneKeyword, this.ofKeyword, symbols), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "oneKeyword";
            case 1: return "ofKeyword";
            case 2: return "symbols";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.oneKeyword;
            case 1: return this.ofKeyword;
            case 2: return this.symbols;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitOneOfSymbol(this); }
}
exports.OneOfSymbol = OneOfSymbol;
/** {@docCategory Nodes} */
class InvalidSymbol extends LexicalSymbolBase {
    constructor() {
        super(tokens_1.SyntaxKind.InvalidSymbol);
    }
    accept(visitor) { return visitor.visitInvalidSymbol(this); }
}
exports.InvalidSymbol = InvalidSymbol;
//
// Primary Symbols
//
/** {@docCategory Nodes} */
class PrimarySymbolBase extends LexicalSymbolBase {
}
exports.PrimarySymbolBase = PrimarySymbolBase;
//
// Optional Symbols
//
/** {@docCategory Nodes} */
class OptionalSymbolBase extends PrimarySymbolBase {
    constructor(kind, questionToken) {
        super(kind);
        this.questionToken = questionToken;
    }
}
exports.OptionalSymbolBase = OptionalSymbolBase;
/**
 * Represents a terminal token in the grammar.
 * ```grammarkdown
 * `yield` `*`?
 * ```
 * {@docCategory Nodes}
 */
class Terminal extends OptionalSymbolBase {
    constructor(literal, questionToken) {
        super(tokens_1.SyntaxKind.Terminal, questionToken);
        this.literal = literal;
    }
    get firstChild() { return this.literal; }
    get lastChild() { var _a; return (_a = this.questionToken) !== null && _a !== void 0 ? _a : this.literal; }
    forEachChild(cbNode) {
        return cbNode(this.literal)
            || (this.questionToken && cbNode(this.questionToken));
    }
    *children() {
        yield this.literal;
        if (this.questionToken)
            yield this.questionToken;
    }
    update(literal, questionToken) {
        return literal !== this.literal || questionToken !== this.questionToken
            ? setTextRange(new Terminal(literal, questionToken), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 2; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "literal";
            case 1: return "questionToken";
        }
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.literal;
            case 1: return this.questionToken;
        }
    }
    accept(visitor) { return visitor.visitTerminal(this); }
}
exports.Terminal = Terminal;
/**
 * Represents a non-terminal reference to another Production.
 * ```grammarkdown
 * IdentifierReference[~Yield, ~Await]
 * ```
 * {@docCategory Nodes}
 */
class Nonterminal extends OptionalSymbolBase {
    constructor(name, argumentList, questionToken) {
        super(tokens_1.SyntaxKind.Nonterminal, questionToken);
        this.name = name;
        this.argumentList = argumentList;
    }
    get firstChild() { return this.name; }
    get lastChild() { return this.questionToken || this.argumentList || this.name; }
    forEachChild(cbNode) {
        return cbNode(this.name)
            || (this.argumentList && cbNode(this.argumentList))
            || (this.questionToken && cbNode(this.questionToken));
    }
    *children() {
        yield this.name;
        if (this.argumentList)
            yield this.argumentList;
        if (this.questionToken)
            yield this.questionToken;
    }
    update(name, argumentList) {
        return name !== this.name || argumentList !== this.argumentList
            ? setTextRange(new Nonterminal(name, argumentList, this.questionToken), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "name";
            case 1: return "argumentList";
            case 2: return "questionToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.name;
            case 1: return this.argumentList;
            case 2: return this.questionToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitNonterminal(this); }
}
exports.Nonterminal = Nonterminal;
//
// Assertions
//
/** {@docCategory Nodes} */
class AssertionBase extends LexicalSymbolBase {
    constructor(kind, openBracketToken, closeBracketToken) {
        super(kind);
        this.openBracketToken = openBracketToken;
        this.closeBracketToken = closeBracketToken;
    }
    get firstChild() { return this.openBracketToken; }
}
exports.AssertionBase = AssertionBase;
/**
 * Represents the `empty` assertion, which matches exactly zero tokens.
 * ```grammarkdown
 * [empty]
 * ```
 * {@docCategory Nodes}
 */
class EmptyAssertion extends AssertionBase {
    constructor(openBracketToken, emptyKeyword, closeBracketToken) {
        super(tokens_1.SyntaxKind.EmptyAssertion, openBracketToken, closeBracketToken);
        this.emptyKeyword = emptyKeyword;
    }
    get lastChild() { return this.closeBracketToken || this.emptyKeyword; }
    forEachChild(cbNode) {
        return cbNode(this.openBracketToken)
            || cbNode(this.emptyKeyword)
            || (this.closeBracketToken && cbNode(this.closeBracketToken));
    }
    *children() {
        yield this.openBracketToken;
        yield this.emptyKeyword;
        if (this.closeBracketToken)
            yield this.closeBracketToken;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "openBracketToken";
            case 1: return "emptyKeyword";
            case 2: return "closeBracketToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.openBracketToken;
            case 1: return this.emptyKeyword;
            case 2: return this.closeBracketToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitEmptyAssertion(this); }
}
exports.EmptyAssertion = EmptyAssertion;
/**
 * Represents a `lookahead` assertion, which is a zero-width assertion that only matches if the next token is in the requested set.
 * ```grammarkdown
 * [lookahead ∉ { `class`, `let` }]
 * ```
 * {@docCategory Nodes}
 */
class LookaheadAssertion extends AssertionBase {
    constructor(openBracketToken, lookaheadKeyword, operatorToken, lookahead, closeBracketToken) {
        super(tokens_1.SyntaxKind.LookaheadAssertion, openBracketToken, closeBracketToken);
        this.lookaheadKeyword = lookaheadKeyword;
        this.operatorToken = operatorToken;
        this.lookahead = lookahead;
    }
    get lastChild() { return this.closeBracketToken || this.lookahead || this.operatorToken || this.lookaheadKeyword; }
    forEachChild(cbNode) {
        return cbNode(this.openBracketToken)
            || cbNode(this.lookaheadKeyword)
            || (this.operatorToken && cbNode(this.operatorToken))
            || (this.lookahead && cbNode(this.lookahead))
            || (this.closeBracketToken && cbNode(this.closeBracketToken));
    }
    *children() {
        yield this.openBracketToken;
        yield this.lookaheadKeyword;
        if (this.operatorToken)
            yield this.operatorToken;
        if (this.lookahead)
            yield this.lookahead;
        if (this.closeBracketToken)
            yield this.closeBracketToken;
    }
    update(lookahead) {
        return lookahead !== this.lookahead
            ? setTextRange(new LookaheadAssertion(this.openBracketToken, this.lookaheadKeyword, this.operatorToken, lookahead, this.closeBracketToken), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 5; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "openBracketToken";
            case 1: return "lookaheadKeyword";
            case 2: return "operatorToken";
            case 3: return "lookahead";
            case 4: return "closeBracketToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.openBracketToken;
            case 1: return this.lookaheadKeyword;
            case 2: return this.operatorToken;
            case 3: return this.lookahead;
            case 4: return this.closeBracketToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitLookaheadAssertion(this); }
}
exports.LookaheadAssertion = LookaheadAssertion;
/**
 * Represens a `lexical-goal` assertion which verifies that current lexical goal is the supplied *Nonterminal*.
 * ```grammarkdown
 * [lexical goal Module]
 * ```
 * {@docCategory Nodes}
 */
class LexicalGoalAssertion extends AssertionBase {
    constructor(openBracketToken, lexicalKeyword, goalKeyword, symbol, closeBracketToken) {
        super(tokens_1.SyntaxKind.LexicalGoalAssertion, openBracketToken, closeBracketToken);
        this.lexicalKeyword = lexicalKeyword;
        this.goalKeyword = goalKeyword;
        this.symbol = symbol;
    }
    get lastChild() { return this.closeBracketToken || this.symbol || this.goalKeyword || this.lexicalKeyword; }
    forEachChild(cbNode) {
        return cbNode(this.openBracketToken)
            || cbNode(this.lexicalKeyword)
            || (this.goalKeyword && cbNode(this.goalKeyword))
            || (this.symbol && cbNode(this.symbol))
            || (this.closeBracketToken && cbNode(this.closeBracketToken));
    }
    *children() {
        yield this.openBracketToken;
        yield this.lexicalKeyword;
        if (this.goalKeyword)
            yield this.goalKeyword;
        if (this.symbol)
            yield this.symbol;
        if (this.closeBracketToken)
            yield this.closeBracketToken;
    }
    update(symbol) {
        return symbol !== this.symbol
            ? setTextRange(new LexicalGoalAssertion(this.openBracketToken, this.lexicalKeyword, this.goalKeyword, symbol, this.closeBracketToken), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 5; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "openBracketToken";
            case 1: return "lexicalKeyword";
            case 2: return "goalKeyword";
            case 3: return "symbol";
            case 4: return "closeBracketToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.openBracketToken;
            case 1: return this.lexicalKeyword;
            case 2: return this.goalKeyword;
            case 3: return this.symbol;
            case 4: return this.closeBracketToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitLexicalGoalAssertion(this); }
}
exports.LexicalGoalAssertion = LexicalGoalAssertion;
/**
 * Represents a `no Symbol here` assertion, which disallows the provided symbol.
 * ```grammarkdown
 * [no LineTerminator here]
 * ```
 * {@docCategory Nodes}
 */
class NoSymbolHereAssertion extends AssertionBase {
    constructor(openBracketToken, noKeyword, symbols, hereKeyword, closeBracketToken) {
        super(tokens_1.SyntaxKind.NoSymbolHereAssertion, openBracketToken, closeBracketToken);
        this.noKeyword = noKeyword;
        this.symbols = symbols;
        this.hereKeyword = hereKeyword;
    }
    get lastChild() { return this.closeBracketToken || this.hereKeyword || (0, core_1.last)(this.symbols) || this.noKeyword; }
    forEachChild(cbNode) {
        return cbNode(this.openBracketToken)
            || cbNode(this.noKeyword)
            || (this.symbols && (0, core_1.forEach)(this.symbols, cbNode))
            || (this.hereKeyword && cbNode(this.hereKeyword))
            || (this.closeBracketToken && cbNode(this.closeBracketToken));
    }
    *children() {
        yield this.openBracketToken;
        yield this.noKeyword;
        if (this.symbols)
            yield* this.symbols;
        if (this.hereKeyword)
            yield this.hereKeyword;
        if (this.closeBracketToken)
            yield this.closeBracketToken;
    }
    update(symbols) {
        return symbols !== this.symbols
            ? setTextRange(new NoSymbolHereAssertion(this.openBracketToken, this.noKeyword, symbols, this.hereKeyword, this.closeBracketToken), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 5; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "openBracketToken";
            case 1: return "noKeyword";
            case 2: return "symbols";
            case 3: return "hereKeyword";
            case 4: return "closeBracketToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.openBracketToken;
            case 1: return this.noKeyword;
            case 2: return this.symbols;
            case 3: return this.hereKeyword;
            case 4: return this.closeBracketToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitNoSymbolHereAssertion(this); }
}
exports.NoSymbolHereAssertion = NoSymbolHereAssertion;
/**
 * Represents an assertion containing Prose, which indicates handling of syntax outside the scope of the Grammarkdown parser.
 * ```grammarkdown
 * HexDigits [> but only if MV of |HexDigits| > 0x10FFFF]
 * ```
 * {@docCategory Nodes}
 */
class ProseAssertion extends AssertionBase {
    constructor(openBracketToken, fragments, closeBracketToken) {
        super(tokens_1.SyntaxKind.ProseAssertion, openBracketToken, closeBracketToken);
        this.fragments = fragments;
    }
    get lastChild() { return this.closeBracketToken || (0, core_1.last)(this.fragments) || this.openBracketToken; }
    forEachChild(cbNode) {
        return cbNode(this.openBracketToken)
            || (this.fragments && (0, core_1.forEach)(this.fragments, cbNode))
            || (this.closeBracketToken && cbNode(this.closeBracketToken));
    }
    *children() {
        yield this.openBracketToken;
        if (this.fragments)
            yield* this.fragments;
        if (this.closeBracketToken)
            yield this.closeBracketToken;
    }
    update(fragments) {
        return fragments !== this.fragments
            ? setTextRange(new ProseAssertion(this.openBracketToken, fragments, this.closeBracketToken), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "openBracketToken";
            case 1: return "fragments";
            case 2: return "closeBracketToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.openBracketToken;
            case 1: return this.fragments;
            case 2: return this.closeBracketToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitProseAssertion(this); }
}
exports.ProseAssertion = ProseAssertion;
/** {@docCategory Nodes} */
class InvalidAssertion extends AssertionBase {
    constructor(openBracketToken, closeBracketToken) {
        super(tokens_1.SyntaxKind.InvalidAssertion, openBracketToken, closeBracketToken);
    }
    get lastChild() { return this.closeBracketToken || this.openBracketToken; }
    forEachChild(cbNode) {
        return cbNode(this.openBracketToken)
            || (this.closeBracketToken && cbNode(this.closeBracketToken));
    }
    *children() {
        yield this.openBracketToken;
        if (this.closeBracketToken)
            yield this.closeBracketToken;
    }
    get edgeCount() { return 2; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "openBracketToken";
            case 1: return "closeBracketToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.openBracketToken;
            case 1: return this.closeBracketToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitInvalidAssertion(this); }
}
exports.InvalidAssertion = InvalidAssertion;
/** {@docCategory Nodes} */
class ProseFragmentLiteral extends Node {
    constructor(kind, text) {
        super(kind);
        this.text = text;
    }
    get edgeCount() { return 0; }
    edgeName(_offset) { return undefined; }
    edgeValue(_offset) { return undefined; }
    accept(visitor) { return visitor.visitProseFragmentLiteral(this); }
}
exports.ProseFragmentLiteral = ProseFragmentLiteral;
/** {@docCategory Nodes} */
class Argument extends Node {
    constructor(operatorToken, name) {
        super(tokens_1.SyntaxKind.Argument);
        this.operatorToken = operatorToken;
        this.name = name;
    }
    get firstChild() { return this.operatorToken || this.name; }
    get lastChild() { return this.name || this.operatorToken; }
    forEachChild(cbNode) {
        return (this.operatorToken && cbNode(this.operatorToken))
            || (this.name && cbNode(this.name));
    }
    *children() {
        if (this.operatorToken)
            yield this.operatorToken;
        if (this.name)
            yield this.name;
    }
    update(name) {
        return name !== name
            ? setTextRange(new Argument(this.operatorToken, name), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 2; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "operatorToken";
            case 1: return "name";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.operatorToken;
            case 1: return this.name;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitArgument(this); }
}
exports.Argument = Argument;
/** {@docCategory Nodes} */
class ArgumentList extends Node {
    constructor(openParenToken, elements, closeParenToken) {
        super(tokens_1.SyntaxKind.ArgumentList);
        this.openBracketToken = openParenToken;
        this.elements = elements;
        this.closeBracketToken = closeParenToken;
    }
    get firstChild() { return this.openBracketToken; }
    get lastChild() { return this.closeBracketToken || (0, core_1.last)(this.elements) || this.openBracketToken; }
    forEachChild(cbNode) {
        return cbNode(this.openBracketToken)
            || (this.elements && (0, core_1.forEach)(this.elements, cbNode))
            || (this.closeBracketToken && cbNode(this.closeBracketToken));
    }
    *children() {
        yield this.openBracketToken;
        if (this.elements)
            yield* this.elements;
        if (this.closeBracketToken)
            yield this.closeBracketToken;
    }
    update(elements) {
        return elements !== this.elements
            ? setTextRange(new ArgumentList(this.openBracketToken, elements, this.closeBracketToken), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "openParenToken";
            case 1: return "elements";
            case 2: return "closeParenToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.openBracketToken;
            case 1: return this.elements;
            case 2: return this.closeBracketToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitArgumentList(this); }
}
exports.ArgumentList = ArgumentList;
/** {@docCategory Nodes} */
class SymbolSpan extends Node {
    constructor(symbol, next) {
        super(tokens_1.SyntaxKind.SymbolSpan);
        this.symbol = symbol;
        this.next = next;
    }
    get firstChild() { return this.symbol; }
    get lastChild() { return this.next || this.symbol; }
    forEachChild(cbNode) {
        return cbNode(this.symbol)
            || (this.next && cbNode(this.next));
    }
    *children() {
        yield this.symbol;
        if (this.next)
            yield this.next;
    }
    update(symbol, next) {
        return symbol !== this.symbol || next !== this.next
            ? setTextRange(new SymbolSpan(symbol, next), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 2; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "symbol";
            case 1: return "next";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.symbol;
            case 1: return this.next;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitSymbolSpan(this); }
}
exports.SymbolSpan = SymbolSpan;
/** {@docCategory Nodes} */
class LinkReference extends Node {
    constructor(text) {
        super(tokens_1.SyntaxKind.LinkReference);
        this.text = text;
    }
    forEachChild(_cbNode) { return undefined; }
    children() { return core_1.emptyIterable; }
    get edgeCount() { return 3; }
    edgeName(_offset) { return undefined; }
    edgeValue(_offset) { return undefined; }
    accept(visitor) { return visitor.visitLinkReference(this); }
}
exports.LinkReference = LinkReference;
/** {@docCategory Nodes} */
class ProductionBodyBase extends Node {
}
exports.ProductionBodyBase = ProductionBodyBase;
/** {@docCategory Nodes} */
class RightHandSide extends ProductionBodyBase {
    constructor(constraints, head, reference) {
        super(tokens_1.SyntaxKind.RightHandSide);
        this.constraints = constraints;
        this.head = head;
        this.reference = reference;
    }
    get firstChild() { return this.constraints || this.head; }
    get lastChild() { return this.reference || this.head; }
    forEachChild(cbNode) {
        return (this.constraints && cbNode(this.constraints))
            || (this.head && cbNode(this.head))
            || (this.reference && cbNode(this.reference));
    }
    *children() {
        if (this.constraints)
            yield this.constraints;
        if (this.head)
            yield this.head;
        if (this.reference)
            yield this.reference;
    }
    update(constraints, head, reference) {
        return constraints !== this.constraints, head !== this.head || reference !== this.reference
            ? setTextRange(new RightHandSide(constraints, head, reference), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "constraints";
            case 1: return "head";
            case 2: return "reference";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.constraints;
            case 1: return this.head;
            case 2: return this.reference;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitRightHandSide(this); }
}
exports.RightHandSide = RightHandSide;
/** {@docCategory Nodes} */
class RightHandSideList extends ProductionBodyBase {
    constructor(elements) {
        super(tokens_1.SyntaxKind.RightHandSideList);
        this.elements = elements;
    }
    get firstChild() { return (0, core_1.first)(this.elements); }
    get lastChild() { return (0, core_1.last)(this.elements); }
    forEachChild(cbNode) {
        return (0, core_1.forEach)(this.elements, cbNode);
    }
    *children() {
        if (this.elements)
            yield* this.elements;
    }
    update(elements) {
        return elements !== this.elements
            ? setTextRange(new RightHandSideList(elements), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 1; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "elements";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.elements;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitRightHandSideList(this); }
}
exports.RightHandSideList = RightHandSideList;
/** {@docCategory Nodes} */
class OneOfList extends ProductionBodyBase {
    constructor(oneKeyword, ofKeyword, indented, terminals) {
        super(tokens_1.SyntaxKind.OneOfList);
        this.oneKeyword = oneKeyword;
        this.ofKeyword = ofKeyword;
        this.indented = indented;
        this.terminals = terminals;
    }
    get firstChild() { return this.oneKeyword; }
    get lastChild() { return (0, core_1.last)(this.terminals) || this.ofKeyword || this.oneKeyword; }
    forEachChild(cbNode) {
        return cbNode(this.oneKeyword)
            || (this.ofKeyword && cbNode(this.ofKeyword))
            || (this.terminals && (0, core_1.forEach)(this.terminals, cbNode));
    }
    *children() {
        yield this.oneKeyword;
        if (this.ofKeyword)
            yield this.ofKeyword;
        if (this.terminals)
            yield* this.terminals;
    }
    update(terminals) {
        return terminals !== this.terminals
            ? setTextRange(new OneOfList(this.oneKeyword, this.ofKeyword, this.indented, terminals), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "oneKeyword";
            case 1: return "ofKeyword";
            case 2: return "terminals";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.oneKeyword;
            case 1: return this.ofKeyword;
            case 2: return this.terminals;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitOneOfList(this); }
}
exports.OneOfList = OneOfList;
/** {@docCategory Nodes} */
class Parameter extends Node {
    constructor(name) {
        super(tokens_1.SyntaxKind.Parameter);
        this.name = name;
    }
    get firstChild() { return this.name; }
    get lastChild() { return this.name; }
    forEachChild(cbNode) {
        return (this.name && cbNode(this.name));
    }
    *children() {
        if (this.name)
            yield this.name;
    }
    update(name) {
        return name !== this.name
            ? setTextRange(new Parameter(name), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 1; }
    edgeName(offset) { return offset === 0 ? "name" : undefined; }
    edgeValue(offset) { return offset === 0 ? this.name : undefined; }
    accept(visitor) { return visitor.visitParameter(this); }
}
exports.Parameter = Parameter;
/** {@docCategory Nodes} */
class ParameterList extends Node {
    constructor(openParenToken, elements, closeParenToken) {
        super(tokens_1.SyntaxKind.ParameterList);
        this.openBracketToken = openParenToken;
        this.elements = elements;
        this.closeBracketToken = closeParenToken;
    }
    get firstChild() { return this.openBracketToken; }
    get lastChild() { return this.closeBracketToken || (0, core_1.last)(this.elements) || this.openBracketToken; }
    forEachChild(cbNode) {
        return cbNode(this.openBracketToken)
            || (this.elements && (0, core_1.forEach)(this.elements, cbNode))
            || (this.closeBracketToken && cbNode(this.closeBracketToken));
    }
    *children() {
        yield this.openBracketToken;
        if (this.elements)
            yield* this.elements;
        if (this.closeBracketToken)
            yield this.closeBracketToken;
    }
    update(elements) {
        return elements !== this.elements
            ? setTextRange(new ParameterList(this.openBracketToken, elements, this.closeBracketToken), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "openParenToken";
            case 1: return "elements";
            case 2: return "closeParenToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.openBracketToken;
            case 1: return this.elements;
            case 2: return this.closeBracketToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitParameterList(this); }
}
exports.ParameterList = ParameterList;
/** {@docCategory Nodes} */
class SourceElementBase extends Node {
}
exports.SourceElementBase = SourceElementBase;
/** {@docCategory Nodes} */
class Production extends SourceElementBase {
    constructor(name, parameterList, colonToken, body) {
        super(tokens_1.SyntaxKind.Production);
        this.name = name;
        this.parameterList = parameterList;
        this.colonToken = colonToken;
        this.body = body;
    }
    get firstChild() { return this.name; }
    get lastChild() { return this.body || this.colonToken || this.parameterList || this.name; }
    forEachChild(cbNode) {
        return cbNode(this.name)
            || (this.parameterList && cbNode(this.parameterList))
            || (this.colonToken && cbNode(this.colonToken))
            || (this.body && cbNode(this.body));
    }
    *children() {
        yield this.name;
        if (this.colonToken)
            yield this.colonToken;
        if (this.parameterList)
            yield this.parameterList;
        if (this.body)
            yield this.body;
    }
    update(name, parameterList, body) {
        return name !== this.name || parameterList !== this.parameterList || body !== this.body
            ? setTextRange(new Production(name, parameterList, this.colonToken, body), this.pos, this.end)
            : this;
    }
    get edgeCount() { return 4; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "name";
            case 1: return "parameterList";
            case 2: return "colonToken";
            case 3: return "body";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.name;
            case 1: return this.parameterList;
            case 2: return this.colonToken;
            case 3: return this.body;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitProduction(this); }
}
exports.Production = Production;
/** {@docCategory Nodes} */
class MetaElementBase extends SourceElementBase {
    constructor(kind, atToken) {
        super(kind);
        this.atToken = atToken;
    }
    get firstChild() { return this.atToken; }
}
exports.MetaElementBase = MetaElementBase;
/** {@docCategory Nodes} */
class Import extends MetaElementBase {
    constructor(atToken, importKeyword, path) {
        super(tokens_1.SyntaxKind.Import, atToken);
        this.importKeyword = importKeyword;
        this.path = path;
    }
    get lastChild() { return this.path || this.importKeyword; }
    forEachChild(cbNode) {
        return cbNode(this.atToken)
            || cbNode(this.importKeyword)
            || (this.path && cbNode(this.path));
    }
    *children() {
        yield this.atToken;
        yield this.importKeyword;
        if (this.path)
            yield this.path;
    }
    get edgeCount() { return 3; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "atToken";
            case 1: return "importKeyword";
            case 2: return "path";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.atToken;
            case 1: return this.importKeyword;
            case 2: return this.path;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitImport(this); }
}
exports.Import = Import;
/** {@docCategory Nodes} */
class Define extends MetaElementBase {
    constructor(atToken, defineKeyword, key, valueToken) {
        super(tokens_1.SyntaxKind.Define, atToken);
        this.defineKeyword = defineKeyword;
        this.key = key;
        this.valueToken = valueToken;
    }
    get lastChild() { return this.valueToken || this.key || this.defineKeyword; }
    forEachChild(cbNode) {
        return cbNode(this.atToken)
            || cbNode(this.defineKeyword)
            || (this.key && cbNode(this.key))
            || (this.valueToken && cbNode(this.valueToken));
    }
    *children() {
        yield this.atToken;
        yield this.defineKeyword;
        if (this.key)
            yield this.key;
        if (this.valueToken)
            yield this.valueToken;
    }
    get edgeCount() { return 4; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "atToken";
            case 1: return "defineKeyword";
            case 2: return "key";
            case 3: return "valueToken";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.atToken;
            case 1: return this.defineKeyword;
            case 2: return this.key;
            case 3: return this.valueToken;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitDefine(this); }
}
exports.Define = Define;
/** {@docCategory Nodes} */
class Line extends MetaElementBase {
    constructor(atToken, lineKeyword, number, path) {
        super(tokens_1.SyntaxKind.Line, atToken);
        this.lineKeyword = lineKeyword;
        this.number = number;
        this.path = path;
    }
    get lastChild() { return this.path || this.number || this.lineKeyword; }
    forEachChild(cbNode) {
        return cbNode(this.atToken)
            || cbNode(this.lineKeyword)
            || (this.number && cbNode(this.number))
            || (this.path && cbNode(this.path));
    }
    *children() {
        yield this.atToken;
        yield this.lineKeyword;
        if (this.number)
            yield this.number;
        if (this.path)
            yield this.path;
    }
    get edgeCount() { return 4; }
    edgeName(offset) {
        switch (offset) {
            case 0: return "atToken";
            case 1: return "lineKeyword";
            case 2: return "number";
            case 3: return "path";
        }
        return undefined;
    }
    edgeValue(offset) {
        switch (offset) {
            case 0: return this.atToken;
            case 1: return this.lineKeyword;
            case 2: return this.number;
            case 3: return this.path;
        }
        return undefined;
    }
    accept(visitor) { return visitor.visitLine(this); }
}
exports.Line = Line;
/** {@docCategory Nodes} */
class SourceFile extends Node {
    constructor(filename, text, elements) {
        super(tokens_1.SyntaxKind.SourceFile);
        this.elements = elements;
        this.filename = filename;
        this.text = text;
        this.lineMap = new diagnostics_1.LineMap(text);
        setTextRange(this, 0, this.text.length);
    }
    get firstChild() { return (0, core_1.first)(this.elements); }
    get lastChild() { return (0, core_1.last)(this.elements); }
    get imports() { return this._imports; }
    forEachChild(cbNode) {
        return (this.elements && (0, core_1.forEach)(this.elements, cbNode));
    }
    *children() {
        if (this.elements)
            yield* this.elements;
    }
    update(elements) {
        return elements !== this.elements
            ? new SourceFile(this.filename, this.text, elements)
            : this;
    }
    get edgeCount() { return 1; }
    edgeName(offset) { return offset === 0 ? "elements" : undefined; }
    edgeValue(offset) { return offset === 0 ? this.elements : undefined; }
    accept(visitor) { return visitor.visitSourceFile(this); }
}
exports.SourceFile = SourceFile;
(() => {
    (0, nodeInternal_1.setSourceFileAccessor)({
        setImports(node, imports) { node._imports = imports; },
        setParseDiagnostics(node, parseDiagnostics) { node._parseDiagnostics = parseDiagnostics; },
        getParseDiagnostics(node) { return node._parseDiagnostics; },
    });
})();
function forEachChild(node, cbNode) {
    return node && node.forEachChild(cbNode);
}
exports.forEachChild = forEachChild;
function setTextRange(node, pos, end) {
    (0, nodeInternal_1.getNodeAccessor)().setTextRange(node, pos, end);
    return node;
}
//# sourceMappingURL=nodes.js.map