import { SourceFile } from "./nodes";
export interface Region<T> {
    readonly line: number;
    readonly value: T;
}
export interface ReadonlyRegionMap<T> {
    findRegion(sourceFile: SourceFile, line: number): Region<T> | undefined;
    regions(sourceFile: SourceFile, line: number): IterableIterator<Region<T>>;
}
export declare class RegionMap<T> implements ReadonlyRegionMap<T> {
    private _sourceFileRegions?;
    private _equateRegions;
    constructor(equateValues: (a: T, b: T) => boolean);
    /**
     * Adds a `Region` for a source file.
     * @param sourceFile The source file in which to add a region
     * @param line The line number of the region start
     * @param value The value for the region
     */
    addRegion(sourceFile: SourceFile | string, line: number, value: T): void;
    /**
     * Adds or updates a `Region` for a source file.
     * @param sourceFile The source file in which to add a region
     * @param line The line number of the region start
     * @param value The value for the region
     */
    upsertRegion(sourceFile: SourceFile | string, line: number, upsert: (value: T | undefined) => T): void;
    /**
     * Finds the nearest `Region` that starts at or prior to the provided `line`.
     * @param sourceFile The source file in which to find a region.
     * @param line The line number from which to start searching.
     */
    findRegion(sourceFile: SourceFile | string, line: number): Region<T> | undefined;
    /**
     * Yields each `Region` that starts at or prior to the provided `line`, starting with the nearest `Region` first.
     * @param sourceFile The source file in which to find a region.
     * @param line The line number from which to start searching.
     */
    regions(sourceFile: SourceFile | string, line: number): Generator<Region<T>, void, unknown>;
    copyFrom(other: RegionMap<T>): void;
}
