"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLocalPath = exports.isFileUri = exports.isUri = exports.SharedOperation = exports.AggregateCancelable = exports.toCancelToken = exports.formatEnum = exports.mapSet = exports.forEachPossiblyAsync = exports.isPromise = exports.pipe = exports.promiseFinally = exports.deduplicateSorted = exports.concat = exports.stableSort = exports.only = exports.last = exports.first = exports.identity = exports.emptyIterable = exports.forEach = exports.compare = exports.compareStrings = exports.compareNumbers = exports.binarySearchBy = exports.binarySearch = exports.mapFromObject = void 0;
const url = require("url");
const cancelable_1 = require("@esfx/cancelable");
const async_canceltoken_1 = require("@esfx/async-canceltoken");
const disposable_1 = require("@esfx/disposable");
// NOTE: grammarkdown requires a minimum of ES5.
if (typeof Object.create !== "function")
    throw new Error("Grammarkdown requires a minimum host engine of ES5.");
const hasOwnProperty = Object.prototype.hasOwnProperty;
function mapFromObject(object) {
    const map = new Map();
    for (const p in object) {
        if (hasOwnProperty.call(object, p)) {
            map.set(p, object[p]);
        }
    }
    return map;
}
exports.mapFromObject = mapFromObject;
function binarySearch(array, value) {
    return binarySearchBy(array, value, identity, compareNumbers);
}
exports.binarySearch = binarySearch;
function binarySearchBy(array, key, selector, comparison = compare) {
    if (array.length === 0 || comparison(key, selector(array[0])) < 0) {
        return -1;
    }
    if (comparison(key, selector(array[array.length - 1])) > 0) {
        return ~array.length;
    }
    let low = 0;
    let high = array.length - 1;
    while (low <= high) {
        const middle = low + ((high - low) >> 1);
        const mid = selector(array[middle]);
        const cmp = comparison(mid, key);
        if (cmp > 0) {
            high = middle - 1;
        }
        else if (cmp < 0) {
            low = middle + 1;
        }
        else {
            return middle;
        }
    }
    return ~low;
}
exports.binarySearchBy = binarySearchBy;
function compareNumbers(a, b) {
    return a - b;
}
exports.compareNumbers = compareNumbers;
function compareStrings(x, y, ignoreCase) {
    return ignoreCase
        ? compare(x && x.toLocaleLowerCase(), y && y.toLocaleLowerCase())
        : compare(x, y);
}
exports.compareStrings = compareStrings;
function compare(x, y) {
    if (x === y)
        return 0;
    if (x === undefined || x === null)
        return -1;
    if (y === undefined || y === null)
        return +1;
    if (x < y)
        return -1;
    if (x > y)
        return +1;
    return 0;
}
exports.compare = compare;
function forEach(array, cb) {
    if (array !== undefined) {
        for (const item of array) {
            const result = cb(item);
            if (result)
                return result;
        }
    }
}
exports.forEach = forEach;
exports.emptyIterable = {
    next() { return { done: true, value: undefined }; },
    [Symbol.iterator]() { return this; }
};
function identity(value) {
    return value;
}
exports.identity = identity;
function first(iterable) {
    if (iterable === undefined)
        return undefined;
    if (iterable === exports.emptyIterable)
        return undefined;
    if (Array.isArray(iterable))
        return iterable.length > 0 ? iterable[0] : undefined;
    for (const item of iterable)
        return item;
}
exports.first = first;
function last(iterable) {
    if (iterable === undefined)
        return undefined;
    if (iterable === exports.emptyIterable)
        return undefined;
    if (Array.isArray(iterable))
        return iterable.length > 0 ? iterable[iterable.length - 1] : undefined;
    let last;
    for (const item of iterable)
        last = item;
    return last;
}
exports.last = last;
function only(iterable) {
    if (iterable === undefined)
        return undefined;
    if (iterable === exports.emptyIterable)
        return undefined;
    if (Array.isArray(iterable))
        return iterable.length === 1 ? iterable[0] : undefined;
    let only;
    let first = true;
    for (const item of iterable) {
        if (!first)
            return undefined;
        only = item;
    }
    return only;
}
exports.only = only;
function stableSort(array, comparer) {
    const indices = array.map((_, i) => i);
    indices.sort((x, y) => comparer(array[x], array[y]) || x - y);
    return indices.map(i => array[i]);
}
exports.stableSort = stableSort;
function concat(a, b) {
    return a ? b ? a.concat(b) : a : b;
}
exports.concat = concat;
function deduplicateSorted(array, comparer) {
    if (array.length === 0)
        return [];
    let last = array[0];
    const deduplicated = [last];
    for (let i = 1; i < array.length; i++) {
        const next = array[i];
        const result = comparer(next, last);
        if (result === true || result === 0) {
            continue;
        }
        else if (result !== false && result < 0) {
            throw new Error("Array is unsorted");
        }
        deduplicated.push(last = next);
    }
    return deduplicated;
}
exports.deduplicateSorted = deduplicateSorted;
function promiseFinally(promise, onFinally) {
    return promise.then(value => {
        onFinally();
        return value;
    }, e => {
        onFinally();
        throw e;
    });
}
exports.promiseFinally = promiseFinally;
function pipe(result, next) {
    return isPromise(result) ? result.then(next) : next(result);
}
exports.pipe = pipe;
function isPromise(value) {
    return typeof value === "object" && "then" in value;
}
exports.isPromise = isPromise;
function forEachPossiblyAsync(iterable, callback) {
    const iter = iterable[Symbol.iterator]();
    const next = () => {
        while (true) {
            const { value, done } = iter.next();
            if (done)
                break;
            const result = callback(value);
            if (isPromise(result))
                return pipe(result, next);
        }
    };
    return next();
}
exports.forEachPossiblyAsync = forEachPossiblyAsync;
function mapSet(map, key, value) {
    map.set(key, value);
    return value;
}
exports.mapSet = mapSet;
const enumMembers = Symbol();
/**
 * Formats an enum value as a string for debugging and debug assertions.
 */
/*@internal*/
function formatEnum(value = 0, enumObject, isFlags) {
    const members = getEnumMembers(enumObject);
    if (value === 0) {
        return members.length > 0 && members[0][0] === 0 ? members[0][1] : "0";
    }
    if (isFlags) {
        let result = "";
        let remainingFlags = value;
        for (let i = members.length - 1; i >= 0 && remainingFlags !== 0; i--) {
            const [enumValue, enumName] = members[i];
            if (enumValue !== 0 && (remainingFlags & enumValue) === enumValue) {
                remainingFlags &= ~enumValue;
                result = `${enumName}${result ? ", " : ""}${result}`;
            }
        }
        if (remainingFlags === 0) {
            return result;
        }
    }
    else {
        for (const [enumValue, enumName] of members) {
            if (enumValue === value) {
                return enumName;
            }
        }
    }
    return value.toString();
}
exports.formatEnum = formatEnum;
function getEnumMembers(enumObject) {
    if (enumObject[enumMembers])
        return enumObject[enumMembers];
    const result = [];
    for (const name in enumObject)
        if (Object.prototype.hasOwnProperty.call(enumObject, name)) {
            const value = enumObject[name];
            if (typeof value === "number") {
                result.push([value, name]);
            }
        }
    return enumObject[enumMembers] = stableSort(result, (x, y) => compare(x[0], y[0]));
}
function toCancelToken(cancelable) {
    if (cancelable_1.Cancelable.hasInstance(cancelable)) {
        return async_canceltoken_1.CancelToken.from(cancelable);
    }
}
exports.toCancelToken = toCancelToken;
class AggregateCancelable {
    constructor() {
        this._cancelSource = async_canceltoken_1.CancelToken.source();
        this._subscriptions = new Set();
        this._cancelCount = 0;
    }
    get canBeCanceled() {
        return this._cancelCount >= 0;
    }
    get cancelable() {
        return this._cancelSource.token;
    }
    addCancelable(cancelable) {
        if (this._cancelSource.token.signaled)
            return;
        if (cancelable === undefined || cancelable instanceof async_canceltoken_1.CancelToken && !cancelable.canBeSignaled) {
            // We have an observer that cannot be canceled
            if (this._cancelCount >= 0) {
                this._cancelCount = -1; // -1 indicates we cannot be canceled
                // Remove all subscriptions
                const subscriptions = [...this._subscriptions];
                this._subscriptions.clear();
                for (const subscription of subscriptions) {
                    subscription.unsubscribe();
                }
            }
            return;
        }
        // Track that we can be canceled
        this._cancelCount++;
        // Create a subscription that can only be invoked once
        let invoked = false;
        const subscription = cancelable_1.Cancelable.subscribe(cancelable, () => {
            if (!invoked) {
                invoked = true;
                if (this._cancelCount > 0) {
                    this._cancelCount--;
                    if (this._cancelCount === 0) {
                        this._cancelCount = -2; // indicate we are now canceled.
                        this._cancelSource.cancel();
                    }
                }
            }
        });
        // Return a subscription that can remove this token.
        const unsubscribe = () => {
            if (this._subscriptions.delete(subscription)) {
                subscription.unsubscribe();
            }
        };
        return {
            unsubscribe,
            [disposable_1.Disposable.dispose]: unsubscribe
        };
    }
}
exports.AggregateCancelable = AggregateCancelable;
/**
 * Synchronizes multiple asynchronous cancelable calls for the same resource,
 * such that the operation is only canceled when all callers have canceled.
 */
class SharedOperation {
    constructor(callback) {
        this._callback = callback;
    }
    async invoke(cancelable) {
        const cancelToken = toCancelToken(cancelable);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        if (!this._sharedOperation) {
            const operation = new AggregateCancelable();
            const operationSubscription = operation.cancelable.subscribe(() => {
                if (this._sharedOperation === sharedOperation) {
                    this._sharedOperation = undefined;
                }
            });
            const promise = Promise.resolve((void 0, this._callback)(operation.cancelable));
            const sharedOperation = this._sharedOperation = [operation, promise];
            try {
                return await this._invokeWorker(sharedOperation, cancelToken);
            }
            finally {
                this._sharedOperation = undefined;
                operationSubscription.unsubscribe();
            }
        }
        else {
            return await this._invokeWorker(this._sharedOperation, cancelToken);
        }
    }
    async _invokeWorker(sharedOperation, cancelToken) {
        const [operation, promise] = sharedOperation;
        const subscription = operation.addCancelable(cancelToken);
        try {
            return await promise;
        }
        finally {
            subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
        }
    }
}
exports.SharedOperation = SharedOperation;
function isUri(file) {
    return !/^([\\/]|[a-z]:($|[\\/]))/i.test(file)
        && !!url.parse(file).protocol;
}
exports.isUri = isUri;
function isFileUri(file) {
    return /^file:\/\//.test(file);
}
exports.isFileUri = isFileUri;
function getLocalPath(file) {
    if (/^file:\/\//.test(file)) {
        const parsed = url.parse(file);
        if (parsed.path) {
            if (parsed.hostname) {
                file = `//${parsed.hostname}${decodeURIComponent(parsed.path)}`;
            }
            else {
                file = decodeURIComponent(parsed.path).substr(1);
            }
        }
    }
    return file;
}
exports.getLocalPath = getLocalPath;
//# sourceMappingURL=core.js.map