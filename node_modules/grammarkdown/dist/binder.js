"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Binder = exports.BindingTable = void 0;
const cancelable_1 = require("@esfx/cancelable");
const tokens_1 = require("./tokens");
const symbols_1 = require("./symbols");
/** {@docCategory Bind} */
class BindingTable {
    constructor() {
        this.globals = new symbols_1.SymbolTable();
    }
    /**
     * Gets a value indicating whether this `BindingTable` is empty.
     */
    get isEmpty() {
        return !this._nodeParents
            && !this._nodeSymbols
            && !this._symbolReferences
            && !this._symbolLocals
            && !this._symbolDeclarations
            && this.globals.isEmpty;
    }
    /**
     * Returns whether the provided `Node` has a parent.
     */
    hasParent(node) {
        return node && this._nodeParents ? this._nodeParents.has(node) : false;
    }
    /**
     * Gets the parent of the provided `Node`.
     */
    getParent(node) {
        var _a;
        return node && ((_a = this._nodeParents) === null || _a === void 0 ? void 0 : _a.get(node));
    }
    /**
     * Gets the nearest ancestor of `node` with the provided `kind`.
     */
    getAncestor(node, kind) {
        for (let parent = this.getParent(node); parent; parent = this.getParent(parent)) {
            if (parent.kind === kind) {
                return parent;
            }
        }
        return undefined;
    }
    /**
     * Gets the `SourceFile` containing `node`.
     */
    getSourceFile(node) {
        return (node === null || node === void 0 ? void 0 : node.kind) === tokens_1.SyntaxKind.SourceFile ? node :
            this.getAncestor(node, tokens_1.SyntaxKind.SourceFile);
    }
    /**
     * Returns whether `node` has been bound to a `Symbol`.
     */
    hasSymbol(node) {
        return node && this._nodeSymbols ? this._nodeSymbols.has(node) : false;
    }
    /**
     * Gets the `Symbol` bound to `node`.
     */
    getSymbol(node) {
        var _a;
        return node && ((_a = this._nodeSymbols) === null || _a === void 0 ? void 0 : _a.get(node));
    }
    /**
     * Resolves a `Symbol` for the provided `name` at the given `location` that has the provided `meaning`.
     */
    resolveSymbol(location, name, meaning) {
        if (this._symbolLocals && name) {
            while (location) {
                if (location.kind === tokens_1.SyntaxKind.SourceFile) {
                    const result = this.globals.resolveSymbol(name, meaning);
                    if (result)
                        return result;
                    break;
                }
                const symbol = this.getSymbol(location);
                const locals = symbol ? this._symbolLocals.get(symbol) : undefined;
                const result = locals === null || locals === void 0 ? void 0 : locals.resolveSymbol(name, meaning);
                if (result)
                    return result;
                location = this.getParent(location);
            }
        }
        return undefined;
    }
    /**
     * Gets the declarations for the provided `symbol`.
     */
    getDeclarations(symbol) {
        var _a;
        const declarations = symbol && ((_a = this._symbolDeclarations) === null || _a === void 0 ? void 0 : _a.get(symbol));
        return declarations ? [...declarations] : [];
    }
    /**
     * Gets the references to the provided `symbol`.
     */
    getReferences(symbol) {
        var _a;
        const references = symbol && ((_a = this._symbolReferences) === null || _a === void 0 ? void 0 : _a.get(symbol));
        return references ? [...references] : [];
    }
    /* @internal */
    _copyFrom(other) {
        var _a, _b, _c, _d, _e;
        if (other === this || other.isEmpty)
            return;
        this.globals.copyFrom(other.globals);
        if (other._nodeParents) {
            (_a = this._nodeParents) !== null && _a !== void 0 ? _a : (this._nodeParents = new Map());
            for (const [node, parent] of other._nodeParents) {
                this._nodeParents.set(node, parent);
            }
        }
        if (other._nodeSymbols) {
            (_b = this._nodeSymbols) !== null && _b !== void 0 ? _b : (this._nodeSymbols = new Map());
            for (const [node, symbol] of other._nodeSymbols) {
                this._nodeSymbols.set(node, symbol);
            }
        }
        if (other._symbolDeclarations) {
            (_c = this._symbolDeclarations) !== null && _c !== void 0 ? _c : (this._symbolDeclarations = new Map());
            for (const [symbol, otherDeclarations] of other._symbolDeclarations) {
                let declarations = this._symbolDeclarations.get(symbol);
                if (!declarations)
                    this._symbolDeclarations.set(symbol, declarations = new Set());
                for (const declaration of otherDeclarations) {
                    declarations.add(declaration);
                }
            }
        }
        if (other._symbolReferences) {
            (_d = this._symbolReferences) !== null && _d !== void 0 ? _d : (this._symbolReferences = new Map());
            for (const [symbol, otherReferences] of other._symbolReferences) {
                let references = this._symbolReferences.get(symbol);
                if (!references)
                    this._symbolReferences.set(symbol, references = new Set());
                for (const reference of otherReferences) {
                    references.add(reference);
                }
            }
        }
        if (other._symbolLocals) {
            (_e = this._symbolLocals) !== null && _e !== void 0 ? _e : (this._symbolLocals = new Map());
            for (const [symbol, otherLocals] of other._symbolLocals) {
                let locals = this._symbolLocals.get(symbol);
                if (!locals)
                    this._symbolLocals.set(symbol, locals = new symbols_1.SymbolTable());
                locals.copyFrom(otherLocals);
            }
        }
    }
    /* @internal */
    _setParent(node, parent) {
        var _a;
        if (node && parent) {
            (_a = this._nodeParents) !== null && _a !== void 0 ? _a : (this._nodeParents = new Map());
            this._nodeParents.set(node, parent);
        }
    }
    /* @internal */
    _setSymbol(node, symbol) {
        if (node && symbol) {
            this._setSymbolForNode(node, symbol);
            this._addReferenceToSymbol(symbol, node);
        }
    }
    /* @internal */
    _addDeclarationToSymbol(symbol, node) {
        var _a;
        if (symbol && node) {
            (_a = this._symbolDeclarations) !== null && _a !== void 0 ? _a : (this._symbolDeclarations = new Map());
            let declarations = this._symbolDeclarations.get(symbol);
            if (!declarations)
                this._symbolDeclarations.set(symbol, declarations = new Set());
            declarations.add(node);
            this._setSymbolForNode(node, symbol);
            if (node.kind !== tokens_1.SyntaxKind.SourceFile) {
                this._addReferenceToSymbol(symbol, node.name);
            }
        }
    }
    /* @internal */
    _getScope(container) {
        var _a;
        (_a = this._symbolLocals) !== null && _a !== void 0 ? _a : (this._symbolLocals = new Map());
        let scope = this._symbolLocals.get(container);
        if (!scope)
            this._symbolLocals.set(container, scope = new symbols_1.SymbolTable());
        return scope;
    }
    _setSymbolForNode(node, symbol) {
        var _a;
        (_a = this._nodeSymbols) !== null && _a !== void 0 ? _a : (this._nodeSymbols = new Map());
        this._nodeSymbols.set(node, symbol);
    }
    _addReferenceToSymbol(symbol, node) {
        var _a;
        (_a = this._symbolReferences) !== null && _a !== void 0 ? _a : (this._symbolReferences = new Map());
        let references = this._symbolReferences.get(symbol);
        if (!references)
            this._symbolReferences.set(symbol, references = new Set());
        references.add(node);
    }
}
exports.BindingTable = BindingTable;
/** {@docCategory Bind} */
class Binder {
    /**
     * Binds a `SourceFile` in the provided `BindingTable`.
     */
    bindSourceFile(file, bindings, cancelable) {
        cancelable_1.Cancelable.throwIfSignaled(cancelable);
        if (bindings.globals.resolveSymbol(file.filename, symbols_1.SymbolKind.SourceFile)) {
            // skip files that have already been bound.
            return;
        }
        const fileBindings = new BindingTable();
        const scope = fileBindings.globals;
        const symbol = this._declareSymbol(fileBindings, scope, file.filename, file, symbols_1.SymbolKind.SourceFile);
        this._bindChildren(fileBindings, file, symbol, scope);
        bindings._copyFrom(fileBindings);
    }
    _bindProduction(bindings, scope, node) {
        const symbol = this._declareSymbol(bindings, scope, node.name.text, node, symbols_1.SymbolKind.Production);
        const newScope = bindings._getScope(symbol);
        this._bindChildren(bindings, node, symbol, newScope);
    }
    _bindParameter(bindings, scope, node) {
        const symbol = this._declareSymbol(bindings, scope, node.name.text, node, symbols_1.SymbolKind.Parameter);
        this._bindChildren(bindings, node, symbol, scope);
    }
    _bindChildren(bindings, parentNode, parentSymbol, scope) {
        const saveParentNode = this._parentNode;
        const saveParentSymbol = this._parentSymbol;
        this._parentNode = parentNode;
        this._parentSymbol = parentSymbol;
        for (const child of parentNode.children()) {
            this._bind(bindings, scope, child);
        }
        this._parentSymbol = saveParentSymbol;
        this._parentNode = saveParentNode;
    }
    _bind(bindings, scope, node) {
        if (node) {
            bindings._setParent(node, this._parentNode);
            switch (node.kind) {
                case tokens_1.SyntaxKind.Production:
                    this._bindProduction(bindings, scope, node);
                    break;
                case tokens_1.SyntaxKind.Parameter:
                    this._bindParameter(bindings, scope, node);
                    break;
                default:
                    this._bindChildren(bindings, node, this._parentSymbol, scope);
                    break;
            }
        }
    }
    _declareSymbol(bindings, scope, name, declaration, kind) {
        const symbol = scope.declareSymbol(name, kind, this._parentSymbol);
        bindings._addDeclarationToSymbol(symbol, declaration);
        return symbol;
    }
}
exports.Binder = Binder;
//# sourceMappingURL=binder.js.map