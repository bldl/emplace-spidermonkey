/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
import { Cancelable } from "@esfx/cancelable";
import { BindingTable } from "./binder";
import { DiagnosticMessages } from "./diagnostics";
import { LineOffsetMap } from "./lineOffsetMap";
import { NodeNavigator } from "./navigator";
import { Declaration, Identifier, Node, Parameter, Production, RightHandSide, SourceFile } from "./nodes";
import { CompilerOptions } from "./options";
import { Symbol, SymbolKind } from "./symbols";
import { Position, Range } from "./types";
/** {@docCategory Check} */
export declare class Checker {
    private _options;
    private _checkedFileSet;
    private _bindings;
    private _diagnostics;
    private _sourceFile;
    private _noChecks;
    private _productionParametersByName;
    private _cancelToken?;
    private _nodeLinks?;
    private _symbolLinks?;
    private _lineOffsetMap;
    private _defines;
    private _defineOverrideMap?;
    constructor(options?: CompilerOptions, lineOffsetMap?: LineOffsetMap);
    checkSourceFile(sourceFile: SourceFile, bindings: BindingTable, diagnostics: DiagnosticMessages, cancelable?: Cancelable): void;
    private getDefine;
    private preprocessSourceElement;
    private preprocessDefine;
    private checkGrammarDefine;
    private preprocessLine;
    private checkGrammarLine;
    private checkSourceElement;
    private checkProduction;
    private resolveProduction;
    private checkProductionNonStrict;
    private getProductionParametersByName;
    private checkProductionStrict;
    private checkGrammarProduction;
    private checkParameterList;
    private checkGrammarParameterList;
    private checkParameter;
    private checkOneOfList;
    private checkGrammarOneOfList;
    private checkRightHandSideList;
    private checkGrammarRightHandSideList;
    private checkRightHandSide;
    private checkGrammarRightHandSide;
    private checkLinkReference;
    private checkGrammarLinkReference;
    private checkConstraints;
    private checkGrammarConstraints;
    private checkSymbolSpan;
    private checkGrammarSymbolSpan;
    private checkSymbolSpanOrHigher;
    private checkProse;
    private checkSymbolSpanRest;
    private checkGrammarSymbolSpanRest;
    private checkSymbolOrHigher;
    private checkAssertion;
    private checkGrammarAssertionHead;
    private checkGrammarAssertionTail;
    private checkEmptyAssertion;
    private checkGrammarEmptyAssertion;
    private checkLookaheadAssertion;
    private checkGrammarLookaheadAssertion;
    private checkSymbolSet;
    private checkGrammarSymbolSet;
    private checkLexicalGoalAssertion;
    private checkGrammarLexicalGoalAssertion;
    private checkNoSymbolHereAssertion;
    private checkGrammarNoSymbolHereAssertion;
    private checkProseAssertion;
    private checkGrammarProseAssertionHead;
    private checkProseFragment;
    private checkProseFragmentLiteral;
    private reportInvalidAssertion;
    private checkButNotSymbolOrHigher;
    private checkButNotSymbol;
    private checkGrammarButNotSymbol;
    private checkUnarySymbolOrHigher;
    private checkOneOfSymbol;
    private checkGrammarOneOfSymbol;
    private checkOptionalSymbolOrHigher;
    private checkPrimarySymbol;
    private checkGrammarNonTerminal;
    private checkGrammarOptionalSymbol;
    private checkTerminal;
    private checkTerminalLiteral;
    private checkGrammarTerminalLiteral;
    private checkGrammarUnicodeCharacterRange;
    private checkUnicodeCharacterRange;
    private checkUnicodeCharacterLiteral;
    private checkGrammarUnicodeCharacterLiteralCodePointErrors;
    private checkGrammarUnicodeCharacterLiteralCodePointWarnings;
    private checkGrammarUnicodeCharacterLiteralCharacterNameCodePointDescription;
    private checkGrammarUnicodeCharacterLiteralCharacterNameIdentifier;
    private checkGrammarUnicodeCharacterLiteralCharacterName;
    private checkGrammarUnicodeCharacterLiteral;
    private checkPlaceholder;
    private checkNonterminal;
    private checkNonterminalNonStrict;
    private checkNonterminalStrict;
    private checkArgumentList;
    private checkGrammarArgumentList;
    private checkArgument;
    private checkGrammarArgument;
    private reportInvalidSymbol;
    private markSymbolAsReferenced;
    private resolveIdentifier;
    private checkIdentifier;
    private checkGrammarIdentifier;
    private getNodeLinks;
    private getSymbolLinks;
    private resolveSymbol;
    private reportError;
    private reportGrammarError;
    private reportGrammarErrorForNode;
    private reportGrammarErrorForNodeOrPos;
    private reportInvalidHtmlTrivia;
}
/** {@docCategory Check} */
export declare class Resolver {
    readonly bindings: BindingTable;
    private _lineOffsetMap;
    constructor(bindings: BindingTable, lineOffsetMap?: LineOffsetMap);
    /**
     * Gets the effective filename of a raw position within a source file, taking into account `@line` directives.
     */
    getEffectiveFilenameAtPosition(sourceFile: SourceFile, position: Position): string;
    /**
     * Gets the effective position of a raw position within a source file, taking into account `@line` directives.
     */
    getEffectivePosition(sourceFile: SourceFile, position: Position): Position;
    /**
     * Gets the effective range of a raw range within a source file, taking into account `@line` directives.
     */
    getEffectiveRange(sourceFile: SourceFile, range: Range): Range;
    /**
     * Gets the filename of a parsed grammarkdown file for the provided effective filename and position, taking into account `@line` directives.
     */
    getRawFilenameAtEffectivePosition(filename: string, position: Position): string | undefined;
    /**
     * Gets the position in a parsed grammarkdown file for the provided effective filename and position, taking into account `@line` directives.
     */
    getRawPositionFromEffectivePosition(filename: string, position: Position): Position | undefined;
    /**
     * Gets the range in a parsed grammarkdown file for the provided effective filename and position, taking into account `@line` directives.
     */
    getRawRangeFromEffectiveRange(filename: string, range: Range): Range | undefined;
    /**
     * Gets the parent `Node` for `node`.
     */
    getParent(node: Node): Node | undefined;
    /**
     * Creates a `NodeNavigator` pointing at `node`. Returns `undefined` if `node` does not have a `SourceFile` as an ancestor.
     */
    createNavigator(node: Node): NodeNavigator | undefined;
    /**
     * Gets the `SourceFile` of `node`, if it belongs to one.
     */
    getSourceFileOfNode(node: Node): SourceFile | undefined;
    /**
     * Gets the `Symbol` for `node`, if it has one.
     */
    getSymbolOfNode(node: Node | undefined): Symbol | undefined;
    /**
     * Resolves a `Symbol` for the provided `name` at the given `location` that has the provided `meaning`.
     */
    resolveSymbol(location: Node, name: string, meaning: SymbolKind): Symbol | undefined;
    /**
     * Gets the declarations for the provided identifier.
     */
    getDeclarations(node: Identifier): Declaration[];
    /**
     * Gets the declarations for `name` at the provided `location` that have the given `meaning`.
     */
    getDeclarations(name: string, meaning: SymbolKind.SourceFile, location: Node): SourceFile[];
    /**
     * Gets the declarations for `name` at the provided `location` that have the given `meaning`.
     */
    getDeclarations(name: string, meaning: SymbolKind.Production, location: Node): Production[];
    /**
     * Gets the declarations for `name` at the provided `location` that have the given `meaning`.
     */
    getDeclarations(name: string, meaning: SymbolKind.Parameter, location: Node): Parameter[];
    /**
     * Gets the declarations for `name` at the provided `location` that have the given `meaning`.
     */
    getDeclarations(name: string, meaning: SymbolKind, location: Node): Declaration[];
    /**
     * Gets the references to the provided identifier.
     */
    getReferences(node: Identifier): Node[];
    /**
     * Gets the references to `name` at the provided `location` that have the given `meaning`.
     */
    getReferences(name: string, meaning: SymbolKind, location: Node): Node[];
    /**
     * Get the link id for the `Production` to which the provided `node` resolves.
     */
    getProductionLinkId(node: Identifier): string | undefined;
    /**
     * Gets the right-hand-side link id for the provided `RightHandSide`.
     * @param includePrefix When `true`, prepends the production link id.
     */
    getRightHandSideLinkId(node: RightHandSide, includePrefix: boolean): string;
}
