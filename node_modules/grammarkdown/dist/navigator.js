"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeNavigator = void 0;
const nodes_1 = require("./nodes");
const types_1 = require("./types");
const tokens_1 = require("./tokens");
const scanner_1 = require("./scanner");
const diagnostics_1 = require("./diagnostics");
const nodeInternal_1 = require("./nodeInternal");
const perFileLeadingTokensMap = new WeakMap();
const perFileTrailingTokensMap = new WeakMap();
/**
 * Navigates the syntax-tree of a {@link SourceFile}.
 * {@docCategory Compiler}
 *
 * @remarks
 * Nodes in Grammarkdown's syntax tree are immutable and do not maintain pointers to their parents.
 * This can make traversing through a document somewhat difficult. The NodeNavigator class is intended
 * to improve this process by providing an API that can traverse a syntax tree starting from the root.
 *
 * A NodeNavigator focuses on a specific {@link Node} within a syntax tree, and maintains the
 * path to that node from the root. Various methods on the navigator move the focus, allowing you to
 * navigate to any other node within the syntax tree.
 */
class NodeNavigator {
    constructor(sourceFileOrNavigator) {
        this._copyOnNavigate = false;
        if (sourceFileOrNavigator instanceof NodeNavigator) {
            const navigator = sourceFileOrNavigator;
            this._sourceFile = navigator._sourceFile;
            this._edgeStack = navigator._edgeStack.slice();
            this._arrayStack = navigator._arrayStack.slice();
            this._offsetStack = navigator._offsetStack.slice();
            this._nodeStack = navigator._nodeStack.slice();
            this._currentDepth = this._nodeStack.length - 1;
            this._leadingTokens = navigator._leadingTokens;
            this._trailingTokens = navigator._trailingTokens;
            this._tokenOffset = navigator._tokenOffset;
        }
        else {
            this._sourceFile = sourceFileOrNavigator;
            this._edgeStack = [-1];
            this._arrayStack = [undefined];
            this._offsetStack = [0];
            this._nodeStack = [this._sourceFile];
            this._currentDepth = 0;
            this._leadingTokens = undefined;
            this._trailingTokens = undefined;
            this._tokenOffset = -1;
        }
        this._afterNavigate();
    }
    /**
     * Creates a copy of this {@link NodeNavigator} at the same position.
     */
    clone() {
        return new NodeNavigator(this);
    }
    /**
     * Gets the root {@link SourceFile} node for this navigator.
     */
    getRoot() {
        return this._sourceFile;
    }
    /**
     * Gets the parent {@link Node} of the {@link Node} the navigator is currently focused on.
     */
    getParent() {
        return this._parentNode;
    }
    /**
     * Gets the {@link Node} the navigator is currently focused on.
     */
    getNode() {
        return this._currentNode;
    }
    /**
     * If the {@link Node} the navigator is currently focused on is a {@link TextContentNode}, returns the `text` of the node;
     * Otherwise, returns `undefined`.
     */
    getTextContent() {
        if ((0, tokens_1.isTextContentKind)(this.getKind())) {
            return this._currentNode.text;
        }
    }
    /**
     * Gets the {@link SyntaxKind} of the {@link Node} the navigator is currently focused on.
     */
    getKind() {
        return this._currentNode.kind;
    }
    /**
     * Gets the string representation of the {@link SyntaxKind} of the {@link Node} the navigator is currently focused on.
     */
    getKindString() {
        return (0, tokens_1.tokenToString)(this.getKind());
    }
    /**
     * Gets the name of the property on the parent {@link Node} the navigator is currently focused on.
     */
    getName() {
        return this._leadingTokens ? "(leadingTokens)" :
            this._trailingTokens ? "(trailingTokens)" :
                this._parentNode && (0, nodeInternal_1.getNodeAccessor)().edgeName(this._parentNode, this._currentEdge);
    }
    /**
     * Gets the containing node array of {@link Node} the navigator is currently focused on.
     */
    getArray() {
        return this._leadingTokens || this._trailingTokens || this._currentArray;
    }
    /**
     * Gets the ordinal offset within the containing node array of {@link Node} the navigator is currently focused on.
     */
    getOffset() {
        return this._leadingTokens || this._trailingTokens ? this._tokenOffset : this._currentOffset;
    }
    /**
     * Gets the current depth within the syntax-tree of the current focus of the navigator.
     */
    getDepth() {
        return this._getDepth();
    }
    /**
     * Returns a value indicating whether the focus of the navigator points to a {@link Node} in an array.
     */
    isArray() {
        return this._leadingTokens !== undefined ||
            this._trailingTokens !== undefined ||
            this._currentArray !== undefined;
    }
    /**
     * Returns a value indicating whether the navigator is focused on a leading token of the actual current node.
     */
    isLeadingToken() {
        return !!this._leadingTokens;
    }
    /**
     * Returns a value indicating whether the navigator is focused on a trailing token of the actual current node.
     */
    isTrailingToken() {
        return !!this._trailingTokens;
    }
    /**
     * Returns a value indicating whether the focus of the navigator points to either a {@link Token}, {@link TextContentNode}, or {@link InvalidSymbol} (as long as that `InvalidSymbol` has no trailing tokens).
     */
    isToken() {
        const kind = this.getKind();
        return (0, tokens_1.isTokenKind)(kind)
            || (0, tokens_1.isTextContentKind)(kind)
            || !!this._leadingTokens
            || !!this._trailingTokens
            || kind === tokens_1.SyntaxKind.InvalidSymbol && !(scanInterveningTokens(this._currentNode, this._sourceFile), getTrailingTokens(this._currentNode, this._sourceFile));
    }
    *ancestors(predicateOrKind) {
        const navigator = this.clone();
        while (navigator.moveToParent()) {
            if (matchPredicateOrKind(navigator._currentNode, predicateOrKind))
                yield navigator._currentNode;
        }
    }
    *children(predicateOrKind) {
        const navigator = this.clone();
        if (navigator.moveToFirstChild()) {
            do {
                if (matchPredicateOrKind(navigator._currentNode, predicateOrKind))
                    yield navigator._currentNode;
            } while (navigator.moveToNextSibling());
        }
    }
    *tokens(predicateOrKind) {
        const navigator = this.clone();
        if (navigator.moveToFirstToken()) {
            do {
                if (matchPredicateOrKind(navigator._currentNode, predicateOrKind))
                    yield navigator._currentNode;
            } while (navigator.moveToNextToken());
        }
    }
    hasAncestor(predicateOrKind) {
        for (let nextDepth = this._getDepth() - 1; nextDepth >= 0; nextDepth--) {
            const nextNode = this._nodeStack[nextDepth];
            if (matchPredicateOrKind(nextNode, predicateOrKind)) {
                return true;
            }
        }
        return false;
    }
    hasChildren(predicateOrKind) {
        if (this._hasAnyChildren === false || (0, nodeInternal_1.getNodeAccessor)().edgeCount(this._currentNode) === 0) {
            return false;
        }
        if (predicateOrKind === undefined && this._hasAnyChildren !== undefined) {
            return this._hasAnyChildren;
        }
        for (let nextEdge = 0; nextEdge < (0, nodeInternal_1.getNodeAccessor)().edgeCount(this._currentNode); nextEdge++) {
            const next = (0, nodeInternal_1.getNodeAccessor)().edgeValue(this._currentNode, nextEdge);
            if (isNodeArray(next)) {
                for (let nextOffset = 0; nextOffset < next.length; nextOffset++) {
                    const nextNode = next[nextOffset];
                    if (nextNode && matchPredicateOrKind(nextNode, predicateOrKind)) {
                        return this._hasAnyChildren = true;
                    }
                }
            }
            else if (next && matchPredicateOrKind(next, predicateOrKind)) {
                return this._hasAnyChildren = true;
            }
        }
        if (!predicateOrKind) {
            this._hasAnyChildren = false;
        }
        return false;
    }
    isMatch(predicateOrKind) {
        return this._isMatch(predicateOrKind);
    }
    /**
     * Determines whether this navigator is focused on the same location within the tree as another navigator.
     * @param other The other navigator.
     * @returns `true` if both navigators are focused on the same location within the tree; otherwise, `false`.
     */
    isSamePosition(other) {
        if (this === other) {
            return true;
        }
        return this._sourceFile === other._sourceFile
            && this._currentDepth === other._currentDepth
            && this._currentEdge === other._currentEdge
            && this._currentArray === other._currentArray
            && this._currentOffset === other._currentOffset
            && this._currentNode === other._currentNode
            && this._leadingTokens === other._leadingTokens
            && this._trailingTokens === other._trailingTokens
            && this._tokenOffset === other._tokenOffset;
    }
    /**
     * Moves the focus of this navigator to the same position within the syntax tree as another navigator.
     * @param other The other navigator.
     * @returns `true` if the navigator's focus changed; otherwise, `false`.
     */
    moveTo(other) {
        if (this === other) {
            return true;
        }
        if (this._sourceFile !== other._sourceFile) {
            return false;
        }
        this._currentDepth = other._currentDepth;
        this._edgeStack = other._edgeStack.slice();
        this._arrayStack = other._arrayStack.slice();
        this._offsetStack = other._offsetStack.slice();
        this._nodeStack = other._nodeStack.slice();
        this._leadingTokens = other._leadingTokens;
        this._trailingTokens = other._trailingTokens;
        this._tokenOffset = other._tokenOffset;
        this._afterNavigate();
        return true;
    }
    /**
     * Moves the focus of the navigator to the root of the syntax tree.
     * @returns `true` if the navigator's focus changed; otherwise, `false`.
     */
    moveToRoot() {
        if (this._getDepth() > 0) {
            this._beforeNavigate();
            this._reset();
            this._afterNavigate();
        }
        return true;
    }
    moveToParent(predicateOrKind) {
        if (this._getDepth() > 0) {
            if (matchPredicateOrKind(this._parentNode, predicateOrKind)) {
                this._beforeNavigate();
                this._popEdge();
                this._afterNavigate();
                return true;
            }
        }
        return false;
    }
    moveToAncestorOrSelf(predicateOrKind) {
        return this._isMatch(predicateOrKind)
            || this.moveToAncestor(predicateOrKind);
    }
    moveToAncestor(predicateOrKind) {
        for (let nextDepth = this._getDepth() - 1; nextDepth >= 0; nextDepth--) {
            const nextNode = this._nodeStack[nextDepth];
            if (matchPredicateOrKind(nextNode, predicateOrKind)) {
                this._beforeNavigate();
                while (this._getDepth() !== nextDepth) {
                    this._popEdge();
                }
                this._afterNavigate();
                return true;
            }
        }
        return false;
    }
    /**
     * Moves the focus of the navigator to the parent of the focused {@link Node} if that parent is a {@link SourceElement}.
     * @returns `true` if the navigator's focus changed; otherwise, `false`.
     */
    moveToSourceElement() {
        return this.moveToParent(matchSourceElement);
    }
    /**
     * Moves the focus of the navigator to the parent of the focused {@link Node} if that parent is either a {@link Parameter} or a {@link Production}.
     * @returns `true` if the navigator's focus changed; otherwise, `false`.
     */
    moveToDeclaration() {
        return this.moveToParent(tokens_1.SyntaxKind.Parameter)
            || this.moveToParent(tokens_1.SyntaxKind.Production);
    }
    /**
     * Moves the focus of the navigator to the nearest {@link Identifier}.
     * @returns `true` if the current node is an {@link Identifier} or the navigator's focus changed; otherwise, `false`.
     * @remarks
     * The "nearest {@link Identifier}" is determined using the following rules:
     * <ul>
     * <li>If the focus or its nearest ancestor is a {@link Parameter}, move to the `name` of the {@link Parameter}.</li>
     * <li>If the focus or its nearest ancestor is an {@link Argument}, move to the `name` of the {@link Argument}.</li>
     * <li>If the focus or its nearest ancestor is a {@link Nonterminal}, move to the `name` of the {@link Nonterminal}.</li>
     * <li>If the focus or its nearest ancestor is a {@link LexicalGoalAssertion}, move to the `symbol` of the of the {@link LexicalGoalAssertion}.</li>
     * <li>If the focus or its nearest ancestor is a {@link Define}, move to the `key` of the {@link Define}.</li>
     * <li>If the focus or its nearest ancestor is a {@link Constraints}, move to the `name` of the of the first {@link Argument} of the {@link Constraints}.</li>
     * <li>If the focus is not within the `body` of a {@link Production} and the focus or its nearest ancestor is a {@link Production}, move to the `name` of the {@link Production}.</li>
     * </ul>
     */
    moveToName() {
        if (this.getKind() === tokens_1.SyntaxKind.Identifier) {
            return true;
        }
        else {
            const navigator = this.clone();
            if (navigator.moveToAncestorOrSelf(tokens_1.SyntaxKind.Parameter)
                && navigator.moveToFirstChild("name")) {
                return this.moveTo(navigator);
            }
            navigator.moveTo(this);
            if (navigator.moveToAncestorOrSelf(tokens_1.SyntaxKind.Argument)
                && navigator.moveToFirstChild("name")) {
                return this.moveTo(navigator);
            }
            navigator.moveTo(this);
            if (navigator.moveToAncestorOrSelf(tokens_1.SyntaxKind.Nonterminal)
                && navigator.moveToFirstChild("name")) {
                return this.moveTo(navigator);
            }
            navigator.moveTo(this);
            if (navigator.moveToAncestorOrSelf(tokens_1.SyntaxKind.LexicalGoalAssertion)
                && navigator.moveToFirstChild("symbol")) {
                return this.moveTo(navigator);
            }
            navigator.moveTo(this);
            if (navigator.moveToAncestorOrSelf(tokens_1.SyntaxKind.Constraints)
                && navigator.moveToFirstChild("elements")
                && navigator.moveToFirstChild("name")) {
                return this.moveTo(navigator);
            }
            navigator.moveTo(this);
            if (!navigator.hasAncestor(matchProductionBody)
                && navigator.moveToAncestorOrSelf(tokens_1.SyntaxKind.Production)
                && navigator.moveToFirstChild("name")) {
                return this.moveTo(navigator);
            }
            navigator.moveTo(this);
            if (navigator.moveToParent(tokens_1.SyntaxKind.InvalidAssertion)
                && navigator.moveToParent(tokens_1.SyntaxKind.SymbolSpan)
                && navigator.moveToPreviousSibling(tokens_1.SyntaxKind.Nonterminal)
                && navigator.moveToFirstChild("name")) {
                return this.moveTo(navigator);
            }
        }
        return false;
    }
    moveToFirstChild(predicateOrNameOrKind) {
        return this._moveToChild(Navigation.first, Navigation.next, predicateOrNameOrKind, /*speculative*/ false);
    }
    moveToLastChild(predicateOrNameOrKind) {
        return this._moveToChild(Navigation.last, Navigation.previous, predicateOrNameOrKind, /*speculative*/ false);
    }
    moveToFirstElement(predicateOrKind) {
        return this._moveToElement(Navigation.first, Navigation.next, this._currentEdge, this._currentArray, this._currentOffset, predicateOrKind, /*speculative*/ false);
    }
    moveToPreviousElement(predicateOrKind) {
        return this._moveToElement(Navigation.previous, Navigation.previous, this._currentEdge, this._currentArray, this._currentOffset, predicateOrKind, /*speculative*/ false);
    }
    moveToNextElement(predicateOrKind) {
        return this._moveToElement(Navigation.next, Navigation.next, this._currentEdge, this._currentArray, this._currentOffset, predicateOrKind, /*speculative*/ false);
    }
    moveToLastElement(predicateOrKind) {
        return this._moveToElement(Navigation.last, Navigation.previous, this._currentEdge, this._currentArray, this._currentOffset, predicateOrKind, /*speculative*/ false);
    }
    moveToFirstSibling(predicateOrNameOrKind) {
        return this._moveToSibling(Navigation.first, undefined, Navigation.first, Navigation.next, this._parentNode, predicateOrNameOrKind, /*speculative*/ false);
    }
    moveToPreviousSibling(predicateOrNameOrKind) {
        return this._moveToSibling(Navigation.previous, Navigation.previous, Navigation.last, Navigation.previous, this._parentNode, predicateOrNameOrKind, /*speculative*/ false);
    }
    hasPreviousSibling(predicateOrNameOrKind) {
        return this._moveToSibling(Navigation.previous, Navigation.previous, Navigation.last, Navigation.previous, this._parentNode, predicateOrNameOrKind, /*speculative*/ true);
    }
    moveToNextSibling(predicateOrNameOrKind) {
        return this._moveToSibling(Navigation.next, Navigation.next, Navigation.first, Navigation.next, this._parentNode, predicateOrNameOrKind, /*speculative*/ false);
    }
    hasNextSibling(predicateOrNameOrKind) {
        return this._moveToSibling(Navigation.next, Navigation.next, Navigation.first, Navigation.next, this._parentNode, predicateOrNameOrKind, /*speculative*/ true);
    }
    moveToLastSibling(predicateOrNameOrKind) {
        return this._moveToSibling(Navigation.last, undefined, Navigation.last, Navigation.previous, this._parentNode, predicateOrNameOrKind, /*speculative*/ false);
    }
    moveToFirstToken(predicateOrKind) {
        return this._speculate(() => this._moveToFirstTokenWorker() && this._isMatch(predicateOrKind));
    }
    moveToLastToken(predicateOrKind) {
        return this._speculate(() => this._moveToLastTokenWorker() && this._isMatch(predicateOrKind));
    }
    moveToNextToken(predicateOrKind) {
        return this._speculate(() => this._moveToNextTokenWorker() && this._isMatch(predicateOrKind));
    }
    moveToPreviousToken(predicateOrKind) {
        return this._speculate(() => this._moveToPreviousTokenWorker() && this._isMatch(predicateOrKind));
    }
    /**
     * Moves the focus of the navigator to the {@link Node} that contains the provided [Position](xref:grammarkdown!Position:interface).
     * @param position The [Position](xref:grammarkdown!Position:interface) at which to focus the navigator.
     * @param outermost When `true`, moves to the outermost node containing the provided position.
     * When `false` or not specified, moves to the innermost node containing the provided position.
     * @returns `true` if the navigator's focus changed; otherwise, `false`.
     */
    moveToPosition(position, outermost) {
        const pos = this._sourceFile.lineMap.offsetAt(position);
        return this._speculate(() => {
            this.moveToRoot();
            if (pos === 0) {
                if (outermost) {
                    this.moveToFirstChild();
                }
                else {
                    this.moveToFirstToken();
                }
                return true;
            }
            if (pos === this._sourceFile.text.length) {
                if (outermost) {
                    this.moveToLastChild();
                }
                else {
                    this.moveToLastToken();
                }
                return true;
            }
            if (this._moveToPositionWorker(pos, outermost)) {
                return true;
            }
            return false;
        });
    }
    moveToTouchingToken(position, predicateOrKind) {
        return this._speculate(() => this._moveToTouchingTokenWorker(position) && this._isMatch(predicateOrKind));
    }
    _isMatch(predicateOrKind) {
        return matchPredicateOrKind(this._currentNode, predicateOrKind);
    }
    _moveToPositionWorker(pos, outermost) {
        if (pos >= this._currentNode.pos && pos < this._currentNode.end) {
            if (!outermost) {
                if (this.moveToFirstChild()) {
                    do {
                        if (this._moveToPositionWorker(pos)) {
                            return true;
                        }
                    } while (this.moveToNextSibling());
                    this.moveToParent();
                }
            }
            return true;
        }
        return false;
    }
    _moveToTouchingTokenWorker(position) {
        if (this.moveToPosition(position)) {
            // If the position is inside the trivia of the current node, move to the previous node.
            const tokenPosition = this._sourceFile.lineMap.positionAt(this._currentNode.getStart(this._sourceFile));
            if (types_1.Position.compare(position, tokenPosition) < 0) {
                return this.moveToPreviousToken();
            }
            return true;
        }
        return false;
    }
    _moveToFirstLeadingToken() {
        if (this._parentNode)
            scanInterveningTokens(this._parentNode, this._sourceFile);
        const leadingTokens = getLeadingTokens(this._currentNode, this._sourceFile);
        if (leadingTokens) {
            this._beforeNavigate();
            this._leadingTokens = leadingTokens;
            this._trailingTokens = undefined;
            this._tokenOffset = 0;
            this._afterNavigate();
            return true;
        }
        return false;
    }
    _moveToPreviousLeadingToken() {
        if (this._leadingTokens && this._tokenOffset > 0) {
            this._beforeNavigate();
            this._tokenOffset--;
            this._afterNavigate();
            return true;
        }
        return false;
    }
    _moveToNextLeadingToken() {
        if (this._leadingTokens && this._tokenOffset < this._leadingTokens.length - 1) {
            this._beforeNavigate();
            this._tokenOffset++;
            this._afterNavigate();
            return true;
        }
        return false;
    }
    _moveToLastLeadingToken() {
        if (this._parentNode)
            scanInterveningTokens(this._parentNode, this._sourceFile);
        const leadingTokens = getLeadingTokens(this._currentNode, this._sourceFile);
        if (leadingTokens) {
            this._beforeNavigate();
            this._leadingTokens = leadingTokens;
            this._trailingTokens = undefined;
            this._tokenOffset = leadingTokens.length - 1;
            this._afterNavigate();
            return true;
        }
        return false;
    }
    _moveToFirstTrailingToken() {
        scanInterveningTokens(this._currentNode, this._sourceFile);
        const trailingTokens = getTrailingTokens(this._currentNode, this._sourceFile);
        if (trailingTokens) {
            this._beforeNavigate();
            this._leadingTokens = undefined;
            this._trailingTokens = trailingTokens;
            this._tokenOffset = 0;
            this._afterNavigate();
            return true;
        }
        return false;
    }
    _moveToLastTrailingToken() {
        scanInterveningTokens(this._currentNode, this._sourceFile);
        const trailingTokens = getTrailingTokens(this._currentNode, this._sourceFile);
        if (trailingTokens) {
            this._beforeNavigate();
            this._leadingTokens = undefined;
            this._trailingTokens = trailingTokens;
            this._tokenOffset = trailingTokens.length - 1;
            this._afterNavigate();
            return true;
        }
        return false;
    }
    _moveToPreviousTrailingToken() {
        if (this._trailingTokens && this._tokenOffset > 0) {
            this._beforeNavigate();
            this._tokenOffset--;
            this._afterNavigate();
            return true;
        }
        return false;
    }
    _moveToNextTrailingToken() {
        if (this._trailingTokens && this._tokenOffset < this._trailingTokens.length - 1) {
            this._beforeNavigate();
            this._tokenOffset++;
            this._afterNavigate();
            return true;
        }
        return false;
    }
    _moveToFirstTokenWorker() {
        // find the first token within the `pos` and `end` of the current node.
        while (!this.isToken()) {
            // not a token, try its children
            if (!this.moveToFirstChild()) {
                // no children, try trailing tokens...
                return this._moveToFirstTrailingToken();
            }
            // found a child, try leading tokens...
            if (this._moveToFirstLeadingToken())
                return true;
            // try again with the child...
        }
        return true;
    }
    _moveToLastTokenWorker() {
        // find the last token within the `pos` and `end` of the current node
        while (!this.isToken()) {
            // not a token, try this node's trailing tokens...
            if (this._moveToLastTrailingToken())
                return true;
            // no trailing tokens...
            if (!this.moveToLastChild())
                return false; // no children, nothing else to try
            // try again with the child...
        }
        return true;
    }
    _moveToNextTokenWorker() {
        if (this._leadingTokens) {
            if (this._moveToNextLeadingToken())
                return true; // we got the next leading token
            // done processing leading tokens
            this._beforeNavigate();
            this._leadingTokens = undefined;
            this._tokenOffset = -1;
            this._afterNavigate();
            // we should now be on the node following the leading tokens
            return this._moveToFirstTokenWorker();
        }
        else if (this._trailingTokens) {
            if (this._moveToNextTrailingToken())
                return true; // we got the next trailing token
            // done processing trailing tokens
            this._beforeNavigate();
            this._trailingTokens = undefined;
            this._tokenOffset = -1;
            this._afterNavigate();
            // we should now be on the parent node containing the trailing tokens,
            // need to try with its next sibling...
        }
        // move to the next sibling of this node
        while (!this.moveToNextSibling()) {
            // no sibling, try parents...
            if (!this.moveToParent())
                return false; // no parent, nothing else to try
            // found parent, try trailing tokens...
            if (this._moveToFirstTrailingToken())
                return true; // moved to first trailing token
            // no trailing token, try next sibling of parent...
        }
        // we are at the next sibling, start with its leading tokens (if any)
        if (this._moveToFirstLeadingToken())
            return true;
        // If we are here, we are in some node adjacent to the starting node
        return this._moveToFirstTokenWorker();
    }
    _moveToPreviousTokenWorker() {
        if (this._leadingTokens) {
            if (this._moveToPreviousLeadingToken())
                return true; // we got the previous leading token
            // done processing leading tokens
            this._beforeNavigate();
            this._leadingTokens = undefined;
            this._tokenOffset = -1;
            this._afterNavigate();
            // we should now be on the node following the leading tokens, need to try with
            // the previous sibling...
        }
        else {
            if (this._trailingTokens) {
                if (this._moveToPreviousTrailingToken())
                    return true; // we got the previous trailing token
                // done processing trailing tokens
                this._beforeNavigate();
                this._trailingTokens = undefined;
                this._tokenOffset = -1;
                this._afterNavigate();
                // we should now be on the parent node containing the trailing tokens, need to try
                // with the last child...
                if (this.moveToLastChild()) {
                    // move to the last token of the last child
                    return this._moveToLastTokenWorker();
                }
            }
            // current node is a token, move to any leading tokens
            if (this._moveToLastLeadingToken())
                return true;
            // no leading tokens, need to try with the previous sibling...
        }
        while (!this.moveToPreviousSibling()) {
            // no sibling, try parents...
            if (!this.moveToParent())
                return false; // no parent, nothing else to try
            // found parent, try leading tokens...
            if (this._moveToLastLeadingToken())
                return true; // found leading token of parent
            // no leading token, try next sibling of parent...
        }
        // If we are here, we are in some node adjacent to the starting node
        return this._moveToLastTokenWorker();
    }
    _getDepth() {
        return (this._leadingTokens || this._trailingTokens) ?
            this._currentDepth + 1 :
            this._currentDepth;
    }
    _speculate(cb) {
        const currentDepth = this._currentDepth;
        const edgeStack = this._edgeStack;
        const arrayStack = this._arrayStack;
        const offsetStack = this._offsetStack;
        const nodeStack = this._nodeStack;
        const hasChild = this._hasAnyChildren;
        const leadingTokens = this._leadingTokens;
        const trailingTokens = this._trailingTokens;
        const tokenOffset = this._tokenOffset;
        // The following nodes are set by _afterNavigate based on the saved information above:
        //   this._currentEdge
        //   this._currentArray
        //   this._currentOffset
        //   this._currentNode
        //   this._parentNode
        this._copyOnNavigate = true;
        let result = false;
        try {
            result = cb();
        }
        finally {
            if (!result) {
                this._currentDepth = currentDepth;
                this._edgeStack = edgeStack;
                this._arrayStack = arrayStack;
                this._offsetStack = offsetStack;
                this._nodeStack = nodeStack;
                this._hasAnyChildren = hasChild;
                this._leadingTokens = leadingTokens;
                this._trailingTokens = trailingTokens;
                this._tokenOffset = tokenOffset;
                this._afterNavigate();
            }
        }
        return result;
    }
    _beforeNavigate() {
        if (this._copyOnNavigate) {
            this._edgeStack = this._edgeStack.slice();
            this._arrayStack = this._arrayStack.slice();
            this._offsetStack = this._offsetStack.slice();
            this._nodeStack = this._nodeStack.slice();
            this._copyOnNavigate = false;
        }
    }
    _afterNavigate() {
        this._currentEdge = this._edgeStack[this._currentDepth];
        this._currentArray = this._arrayStack[this._currentDepth];
        this._currentOffset = this._offsetStack[this._currentDepth];
        this._currentNode =
            this._leadingTokens ? this._leadingTokens[this._tokenOffset] :
                this._trailingTokens ? this._trailingTokens[this._tokenOffset] :
                    this._nodeStack[this._currentDepth];
        this._parentNode =
            (this._leadingTokens || this._trailingTokens) ? this._nodeStack[this._currentDepth] :
                this._currentDepth > 0 ? this._nodeStack[this._currentDepth - 1] :
                    undefined;
        this._copyOnNavigate = false;
    }
    _pushEdge() {
        this._edgeStack.push(undefined);
        this._arrayStack.push(undefined);
        this._offsetStack.push(undefined);
        this._nodeStack.push(undefined);
        this._hasAnyChildren = undefined;
        this._leadingTokens = undefined;
        this._trailingTokens = undefined;
        this._tokenOffset = -1;
        this._currentDepth++;
    }
    _setEdge(edge, array, offset, node) {
        this._edgeStack[this._currentDepth] = edge;
        this._arrayStack[this._currentDepth] = array;
        this._offsetStack[this._currentDepth] = offset;
        this._nodeStack[this._currentDepth] = node;
        this._leadingTokens = undefined;
        this._trailingTokens = undefined;
        this._tokenOffset = -1;
        this._hasAnyChildren = undefined;
    }
    _popEdge() {
        // if we have trailing tokens we are in a virtual edge. There's no need to reset the depth.
        if (this._trailingTokens) {
            this._trailingTokens = undefined;
            this._tokenOffset = -1;
        }
        else {
            this._currentDepth--;
            this._edgeStack.pop();
            this._arrayStack.pop();
            this._offsetStack.pop();
            this._nodeStack.pop();
            this._leadingTokens = undefined;
            this._tokenOffset = -1;
            this._hasAnyChildren = this._currentNode !== undefined;
        }
    }
    _moveToChild(initializer, seekDirection, predicateOrNameOrKind, speculative) {
        const name = typeof predicateOrNameOrKind === "string" ? predicateOrNameOrKind : undefined;
        const predicateOrKind = typeof predicateOrNameOrKind !== "string" ? predicateOrNameOrKind : undefined;
        const offset = this._currentEdge;
        const length = (0, nodeInternal_1.getNodeAccessor)().edgeCount(this._currentNode);
        for (let nextEdge = initializer(offset, length); bounded(nextEdge, length); nextEdge = seekDirection(nextEdge, length)) {
            if (!name || (0, nodeInternal_1.getNodeAccessor)().edgeName(this._currentNode, nextEdge) === name) {
                const next = (0, nodeInternal_1.getNodeAccessor)().edgeValue(this._currentNode, nextEdge);
                if (isNodeArray(next)) {
                    const length = next.length;
                    for (let nextOffset = initializer(0, length); bounded(nextOffset, length); nextOffset = seekDirection(nextOffset, length)) {
                        const nextNode = next[nextOffset];
                        if (nextNode && matchPredicateOrKind(nextNode, predicateOrKind)) {
                            if (!speculative) {
                                this._beforeNavigate();
                                this._pushEdge();
                                this._setEdge(nextEdge, next, nextOffset, nextNode);
                                this._afterNavigate();
                            }
                            return true;
                        }
                    }
                }
                else if (next && matchPredicateOrKind(next, predicateOrKind)) {
                    if (!speculative) {
                        this._beforeNavigate();
                        this._pushEdge();
                        this._setEdge(nextEdge, /*array*/ undefined, /*offset*/ undefined, next);
                        this._afterNavigate();
                    }
                    return true;
                }
            }
        }
        return false;
    }
    _moveToElement(currentArrayInitializer, seekDirection, currentEdge, currentArray, currentOffset, predicateOrKind, speculative) {
        if (!currentArray) {
            return false;
        }
        const offset = currentOffset;
        const length = currentArray.length;
        for (let nextOffset = currentArrayInitializer(offset, length); bounded(nextOffset, length); nextOffset = seekDirection(nextOffset, length)) {
            const nextNode = currentArray[nextOffset];
            if (nextNode && matchPredicateOrKind(nextNode, predicateOrKind)) {
                if (!speculative) {
                    this._beforeNavigate();
                    this._setEdge(currentEdge, currentArray, nextOffset, nextNode);
                    this._afterNavigate();
                }
                return true;
            }
        }
        return false;
    }
    _moveToSibling(currentEdgeInitializer, currentArrayInitializer, nextArrayInitializer, seekDirection, parentNode, predicateOrNameOrKind, speculative) {
        if (!parentNode) {
            return false;
        }
        const name = typeof predicateOrNameOrKind === "string" ? predicateOrNameOrKind : undefined;
        const predicateOrKind = typeof predicateOrNameOrKind !== "string" ? predicateOrNameOrKind : undefined;
        if (currentArrayInitializer && this._moveToElement(currentArrayInitializer, seekDirection, this._currentEdge, this._currentArray, this._currentOffset, predicateOrKind, speculative)) {
            return true;
        }
        const offset = this._currentEdge;
        const length = (0, nodeInternal_1.getNodeAccessor)().edgeCount(parentNode);
        for (let nextEdge = currentEdgeInitializer(offset, length); bounded(nextEdge, length); nextEdge = seekDirection(nextEdge, length)) {
            if (!name || (0, nodeInternal_1.getNodeAccessor)().edgeName(parentNode, nextEdge) === name) {
                const next = (0, nodeInternal_1.getNodeAccessor)().edgeValue(parentNode, nextEdge);
                if (isNodeArray(next)) {
                    if (this._moveToElement(nextArrayInitializer, seekDirection, nextEdge, next, 0, predicateOrKind, speculative)) {
                        return true;
                    }
                }
                else {
                    if (next && matchPredicateOrKind(next, predicateOrKind)) {
                        if (!speculative) {
                            this._beforeNavigate();
                            this._setEdge(nextEdge, /*array*/ undefined, /*offset*/ undefined, next);
                            this._afterNavigate();
                        }
                        return true;
                    }
                }
            }
        }
        return false;
    }
    _reset() {
        this._currentDepth = 0;
        this._nodeStack.length = 1;
        this._edgeStack.length = 1;
        this._arrayStack.length = 1;
        this._offsetStack.length = 1;
        this._leadingTokens = undefined;
        this._trailingTokens = undefined;
        this._tokenOffset = -1;
    }
}
exports.NodeNavigator = NodeNavigator;
var Navigation;
(function (Navigation) {
    function first(offset, length) {
        return 0;
    }
    Navigation.first = first;
    function previous(offset, length) {
        return offset - 1;
    }
    Navigation.previous = previous;
    function same(offset, length) {
        return offset;
    }
    Navigation.same = same;
    function next(offset, length) {
        return offset + 1;
    }
    Navigation.next = next;
    function last(offset, length) {
        return length - 1;
    }
    Navigation.last = last;
})(Navigation || (Navigation = {}));
function bounded(offset, length) {
    return offset >= 0 && offset < length;
}
function matchProductionBody(node) {
    return node.kind === tokens_1.SyntaxKind.OneOfList
        || node.kind === tokens_1.SyntaxKind.RightHandSideList
        || node.kind === tokens_1.SyntaxKind.RightHandSide;
}
function matchSourceElement(node) {
    return node.kind === tokens_1.SyntaxKind.Import
        || node.kind === tokens_1.SyntaxKind.Production;
}
function isNodeArray(value) {
    return Array.isArray(value);
}
function matchPredicateOrKind(node, predicateOrKind) {
    return typeof predicateOrKind === "function" ? predicateOrKind(node) :
        typeof predicateOrKind === "number" ? node.kind === predicateOrKind :
            true;
}
function getLeadingTokensMap(sourceFile) {
    let leadingTokensMap = perFileLeadingTokensMap.get(sourceFile);
    if (!leadingTokensMap)
        perFileLeadingTokensMap.set(sourceFile, leadingTokensMap = new Map());
    return leadingTokensMap;
}
function getTrailingTokensMap(sourceFile) {
    let trailingTokensMap = perFileTrailingTokensMap.get(sourceFile);
    if (!trailingTokensMap)
        perFileTrailingTokensMap.set(sourceFile, trailingTokensMap = new Map());
    return trailingTokensMap;
}
function getLeadingTokens(node, sourceFile) {
    var _a;
    return (_a = perFileLeadingTokensMap.get(sourceFile)) === null || _a === void 0 ? void 0 : _a.get(node);
}
function getTrailingTokens(node, sourceFile) {
    var _a;
    return (_a = perFileTrailingTokensMap.get(sourceFile)) === null || _a === void 0 ? void 0 : _a.get(node);
}
function scanInterveningTokens(parent, sourceFile) {
    const trailingTokensMap = getTrailingTokensMap(sourceFile);
    if (trailingTokensMap.has(parent))
        return;
    const leadingTokensMap = getLeadingTokensMap(sourceFile);
    const scanner = new scanner_1.Scanner(sourceFile.filename, sourceFile.text, diagnostics_1.NullDiagnosticMessages.instance);
    let pos = parent.pos;
    const processNode = (child) => {
        const tokens = getTokens(pos, child.pos);
        leadingTokensMap.set(child, tokens);
        pos = child.end;
    };
    const processNodes = (nodes) => {
        for (const child of nodes) {
            const tokens = getTokens(pos, child.pos);
            leadingTokensMap.set(child, tokens);
            pos = child.end;
        }
    };
    const getTokens = (pos, end) => {
        let tokens = null;
        scanner.scanRange(pos, () => {
            while (pos < end) {
                const token = scanner.scan();
                if (token === tokens_1.SyntaxKind.EndOfFileToken)
                    break;
                if (!(0, tokens_1.isTokenKind)(token))
                    throw new Error("Unexpected non-token in trivia");
                const node = new nodes_1.Token(token);
                (0, nodeInternal_1.getNodeAccessor)().setTextRange(node, pos, pos = scanner.getPos());
                (tokens !== null && tokens !== void 0 ? tokens : (tokens = [])).push(node);
            }
        });
        return tokens;
    };
    for (let i = 0; i < (0, nodeInternal_1.getNodeAccessor)().edgeCount(parent); i++) {
        const edge = (0, nodeInternal_1.getNodeAccessor)().edgeValue(parent, i);
        if (Array.isArray(edge)) {
            processNodes(edge);
        }
        else if (edge) {
            processNode(edge);
        }
    }
    trailingTokensMap.set(parent, getTokens(pos, parent.end));
}
//# sourceMappingURL=navigator.js.map