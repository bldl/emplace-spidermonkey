"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Grammar = void 0;
const performance = require("./performance");
const host_1 = require("./host");
const diagnostics_1 = require("./diagnostics");
const lineOffsetMap_1 = require("./lineOffsetMap");
const options_1 = require("./options");
const tokens_1 = require("./tokens");
const binder_1 = require("./binder");
const checker_1 = require("./checker");
const core_1 = require("./core");
const emitter_1 = require("./emitter");
const node_1 = require("./hosts/node");
const nodeInternal_1 = require("./nodeInternal");
/**
 * The primary service used to interact with one or more Grammarkdown {@link SourceFile|SourceFiles}.
 * {@docCategory Compiler}
 */
class Grammar {
    /**
     * @param rootNames The names of the root files used by the grammar.
     * @param options The {@link CompilerOptions} used by the grammar.
     * @param host The [Host](xref:hosts) the grammar uses to interact with the file system.
     */
    constructor(rootNames, options = (0, options_1.getDefaultOptions)(), host = new node_1.NodeAsyncHost()) {
        this._lineOffsetMap = new lineOffsetMap_1.LineOffsetMap();
        this._writeFileFallback = (file, content, cancelToken) => this.writeFile(file, content, cancelToken);
        /**
         * The diagnostic messages produced by the grammar.
         */
        this.diagnostics = new diagnostics_1.DiagnosticMessages(this._lineOffsetMap);
        this._rootNames = rootNames;
        this.options = options;
        this.host = host;
    }
    /**
     * Indicates whether the grammar has been parsed.
     */
    get isParsed() {
        return this._parseState !== undefined;
    }
    /**
     * Indicates whether the grammar has been bound.
     */
    get isBound() {
        return this._bindings !== undefined;
    }
    /**
     * Gets the source files parsed by the grammar.
     * @throws `Error` - Grammar has not yet been parsed.
     */
    get sourceFiles() {
        if (!this._parseState)
            throw new Error("Grammar has not yet been parsed.");
        return this._parseState.sourceFiles;
    }
    /**
     * Gets the root files parsed by the grammar.
     * @throws `Error` - Grammar has not yet been parsed.
     */
    get rootFiles() {
        if (!this._parseState)
            throw new Error("Grammar has not yet been parsed.");
        return this._parseState.rootFiles;
    }
    /**
     * Gets the resolver used to resolve references to bound nodes.
     * @throws `Error` - Grammar has not yet been bound.
     */
    get resolver() {
        var _a;
        if (!this._bindings)
            throw new Error("Grammar has not yet been bound.");
        return (_a = this._innerResolver) !== null && _a !== void 0 ? _a : (this._innerResolver = this.createResolver(this._bindings));
    }
    /**
     * Gets the {@link Binder} used to bind the grammar.
     */
    get binder() {
        var _a;
        return (_a = this._innerBinder) !== null && _a !== void 0 ? _a : (this._innerBinder = this.createBinder(this.options));
    }
    /**
     * Gets the {@link Checker} used to check the grammar.
     */
    get checker() {
        var _a;
        return (_a = this._innerChecker) !== null && _a !== void 0 ? _a : (this._innerChecker = this.createChecker(this.options));
    }
    /**
     * Gets the {@link Emitter} used to emit the grammar.
     */
    get emitter() {
        var _a;
        return (_a = this._innerEmitter) !== null && _a !== void 0 ? _a : (this._innerEmitter = this.createEmitter(this.options));
    }
    /**
     * Converts a string containing Grammarkdown syntax into output based on the provided options.
     * @param content The Grammarkdown source text to convert.
     * @param options The {@link CompilerOptions} used by the grammar.
     * @param hostFallback An optional host to use as a fallback for file system operations.
     * @param cancelable A cancelable object that can be used to abort the operation.
     */
    static async convert(content, options = {}, hostFallback, cancelable) {
        const cancelToken = (0, core_1.toCancelToken)(cancelable);
        const { file, ...restOptions } = options;
        const host = host_1.CoreAsyncHost.forFile(content, file, hostFallback);
        const grammar = new Grammar([host.file], restOptions, host);
        await grammar.parse(cancelToken);
        const sourceFile = grammar.getSourceFile(host.file);
        if (!sourceFile)
            throw new Error(`Unable to resolve single file.`);
        return await grammar.emitString(sourceFile, cancelToken);
    }
    /**
     * Gets the {@link SourceFile} parsed for the provided file path.
     * @param file The path to the source file.
     * @returns The {@link SourceFile} for the provided path, if one was parsed; otherwise, `undefined`.
     */
    getSourceFile(file) {
        file = this._resolveFile(file);
        return this._parseState && this._getSourceFileNoResolve(this._parseState, file);
    }
    /**
     * Asynchronously parses the root files provided to the grammar.
     * @param cancelable A cancelable object that can be used to abort the operation.
     * @returns A `Promise` that is settled when the operation has completed.
     */
    async parse(cancelable) {
        var _a;
        (_a = this._parseShared) !== null && _a !== void 0 ? _a : (this._parseShared = new core_1.SharedOperation(cancelToken => this._parseWorker(cancelToken)));
        await this._parseShared.invoke(cancelable);
    }
    async _parseWorker(cancelToken) {
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        const state = { rootFiles: [], sourceFiles: [], sourceFilesMap: undefined };
        if (this._rootNames) {
            for (const rootName of this._rootNames) {
                await this._processRootFile(state, this._resolveFile(rootName), cancelToken);
            }
        }
        if (!this._parseState) {
            this._parseState = state;
            this._rootNames = undefined;
        }
    }
    /**
     * Asynchronously binds each file in the grammar. Will also parse the grammar if it has not yet been parsed.
     * @param cancelable A cancelable object that can be used to abort the operation.
     * @returns A `Promise` that is settled when the operation has completed.
     */
    async bind(cancelable) {
        const cancelToken = (0, core_1.toCancelToken)(cancelable);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        await this.parse(cancelToken);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        const binder = this.binder;
        performance.mark("beforeBind");
        const bindings = new binder_1.BindingTable();
        for (const sourceFile of this.sourceFiles) {
            binder.bindSourceFile(sourceFile, bindings, cancelToken);
        }
        this._bindings = bindings;
        performance.mark("afterBind");
        performance.measure("bind", "beforeBind", "afterBind");
    }
    /**
     * Asynchronously checks each file in the grammar. Will also parse and bind the grammar if it has not yet been parsed or bound.
     * @param cancelable A cancelable object that can be used to abort the operation.
     * @returns A `Promise` that is settled when the operation has completed.
     */
    async check(sourceFile, cancelable) {
        const cancelToken = (0, core_1.toCancelToken)(cancelable);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        await this.bind(cancelToken);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        const subscription = cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.subscribe(() => {
            this._innerChecker = undefined;
            this._innerEmitter = undefined;
        });
        const checker = this.checker;
        performance.mark("beforeCheck");
        if (sourceFile) {
            checker.checkSourceFile(sourceFile, this._bindings, this.diagnostics, cancelToken);
        }
        else {
            for (const sourceFile of this.sourceFiles) {
                checker.checkSourceFile(sourceFile, this._bindings, this.diagnostics, cancelToken);
            }
        }
        performance.mark("afterCheck");
        performance.measure("check", "beforeCheck", "afterCheck");
        subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
    }
    /**
     * Asynchronously emits each file in the grammar. Will also parse, bind, and check the grammar if it has not yet been parsed, bound, or checked.
     * @param sourceFile The {@link SourceFile} to emit. If not provided, this method will generate output for all root files.
     * @param writeFile An optional callback used to write the output. If not provided, this method will emit output via this grammar's {@link Grammar.host|host}.
     * @param cancelable A cancelable object that can be used to abort the operation.
     * @returns A `Promise` that is settled when the operation has completed.
     */
    async emit(sourceFile, writeFile = this._writeFileFallback, cancelable) {
        const cancelToken = (0, core_1.toCancelToken)(cancelable);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        await this.check(sourceFile, cancelToken);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        if (sourceFile) {
            await this._emitOne(sourceFile, writeFile, cancelToken);
        }
        else {
            await Promise.all(this.rootFiles.map(file => this._emitOne(file, writeFile, cancelToken)));
        }
    }
    async _emitOne(sourceFile, writeFile, cancelToken) {
        return this.emitter.emit(sourceFile, this.resolver, this.diagnostics, writeFile, cancelToken);
    }
    /**
     * Asynchronously emits the provided file in the grammar as a string. Will also parse, bind, and check the grammar if it has not yet been parsed, bound, or checked.
     * @param sourceFile The {@link SourceFile} to emit.
     * @param cancelable A cancelable object that can be used to abort the operation.
     * @returns A `Promise` for the emit output that is settled when the operation has completed.
     */
    async emitString(sourceFile, cancelable) {
        const cancelToken = (0, core_1.toCancelToken)(cancelable);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        await this.check(sourceFile, cancelToken);
        cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.throwIfSignaled();
        return this.emitter.emitString(sourceFile, this.resolver, this.diagnostics, cancelToken);
    }
    /**
     * When overridden in a derived class, creates a {@link Binder} to be used by this grammar.
     * @param options The options to pass on to the {@link Binder}.
     * @virtual
     */
    createBinder(options) {
        return new binder_1.Binder();
    }
    /**
     * When overridden in a derived class, creates a {@link Checker} to be used by this grammar.
     * @param options The options to pass on to the {@link Checker}.
     * @virtual
     */
    createChecker(options) {
        return new checker_1.Checker(options, this._lineOffsetMap);
    }
    /**
     * When overridden in a derived class, creates a {@link Resolver} to be used by this grammar.
     * @param bindings A {@link BindingTable} used by the resolver to resolve references to nodes.
     * @virtual
     */
    createResolver(bindings) {
        return new checker_1.Resolver(bindings, this._lineOffsetMap);
    }
    /**
     * When overridden in a derived class, creates an {@link Emitter} to be used by this grammar.
     * @param options The options to pass on to the {@link Emitter}.
     * @virtual
     */
    createEmitter(options) {
        switch (options.format) {
            case options_1.EmitFormat.ecmarkup:
                return new emitter_1.EcmarkupEmitter(options);
            case options_1.EmitFormat.html:
                return new emitter_1.HtmlEmitter(options);
            case options_1.EmitFormat.markdown:
            default:
                return new emitter_1.MarkdownEmitter(options);
        }
    }
    /**
     * When overridden in a derived class, asynchronously reads the contents of the provided file.
     * @param file The file to read.
     * @param cancelToken A cancellation token that can be used by the caller to abort the operation.
     * @returns A `Promise` for either a `string` containing the content if the file could be read, or `undefined` if the file could not be read.
     * @virtual
     */
    readFile(file, cancelToken) {
        return this.host.readFile(file, cancelToken);
    }
    /**
     * When overridden in a derived class, asynchronously writes a file to the host.
     * @param file The path to the file.
     * @param text The contents of the file.
     * @param cancelToken A cancellation token that can be used by the caller to abort the operation.
     * @returns A `Promise` that is settled when the operation completes.
     * @virtual
     */
    writeFile(file, content, cancelToken) {
        return this.host.writeFile(file, content, cancelToken);
    }
    _resolveFile(file, referer) {
        return this.host.resolveFile(file, referer);
    }
    _normalizeFile(file) {
        return this.host.normalizeFile(file);
    }
    async _processRootFile(state, file, cancelToken) {
        const sourceFile = await this._processFile(state, file, cancelToken);
        if (sourceFile === undefined) {
            throw new Error("Invalid source file");
        }
        if (state.rootFiles.indexOf(sourceFile) === -1) {
            state.rootFiles.push(sourceFile);
        }
    }
    async _processFile(state, file, cancelToken, referrer, referrerPos, referrerEnd) {
        let sourceFile = this._getSourceFileNoResolve(state, file);
        if (sourceFile)
            return sourceFile;
        sourceFile = await this.host.getSourceFile(file, cancelToken);
        if (!sourceFile)
            return undefined;
        state.sourceFiles.push(sourceFile);
        this._setSourceFileNoResolve(state, file, sourceFile);
        const parseDiagnostics = (0, nodeInternal_1.getSourceFileAccessor)().getParseDiagnostics(sourceFile);
        if (parseDiagnostics) {
            this.diagnostics.copyFrom(parseDiagnostics);
        }
        await this._processImports(state, sourceFile, file, cancelToken);
        return sourceFile;
    }
    async _processImports(state, sourceFile, referrerName, cancelToken) {
        var _a;
        for (const element of sourceFile.elements) {
            if (element.kind === tokens_1.SyntaxKind.Import && typeof ((_a = element.path) === null || _a === void 0 ? void 0 : _a.text) === "string") {
                const importPath = this._resolveFile(element.path.text, referrerName);
                await this._processFile(state, importPath, cancelToken, sourceFile, element.getStart(sourceFile), element.end);
            }
        }
    }
    _getSourceFileNoResolve(state, file) {
        var _a;
        file = this._normalizeFile(file);
        return (_a = state.sourceFilesMap) === null || _a === void 0 ? void 0 : _a.get(file);
    }
    _setSourceFileNoResolve(state, file, sourceFile) {
        var _a;
        file = this._normalizeFile(file);
        ((_a = state.sourceFilesMap) !== null && _a !== void 0 ? _a : (state.sourceFilesMap = new Map())).set(file, sourceFile);
    }
}
exports.Grammar = Grammar;
//# sourceMappingURL=grammar.js.map