"use strict";
/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeVisitor = void 0;
const nodeInternal_1 = require("./nodeInternal");
/** {@docCategory Other} */
class NodeVisitor {
    visit(node) {
        return node && (0, nodeInternal_1.getNodeAccessor)().accept(node, this);
    }
    visitEach(nodes) {
        let result;
        if (nodes) {
            for (let i = 0; i < nodes.length; i++) {
                if (result) {
                    result.push(this.visit(nodes[i]));
                }
                else {
                    const node = nodes[i];
                    const visited = this.visit(node);
                    if (visited !== node) {
                        result = nodes.slice(0, i);
                        result[i] = visited;
                    }
                }
            }
        }
        return result || nodes;
    }
    visitExtension(node) {
        return node;
    }
    visitToken(node) {
        return node;
    }
    visitStringLiteral(node) {
        return node;
    }
    visitNumberLiteral(node) {
        return node;
    }
    visitIdentifier(node) {
        return node;
    }
    visitInvalidSymbol(node) {
        return node;
    }
    visitPlaceholderSymbol(node) {
        return node;
    }
    visitUnicodeCharacterLiteral(node) {
        return node;
    }
    visitUnicodeCharacterRange(node) {
        return node.update(this.visit(node.left), this.visit(node.right));
    }
    visitButNotSymbol(node) {
        return node.update(this.visit(node.left), this.visit(node.right));
    }
    visitTerminalLiteral(node) {
        return node;
    }
    visitSymbolSet(node) {
        return node.update(this.visitEach(node.elements));
    }
    visitInvalidAssertion(node) {
        return node;
    }
    visitEmptyAssertion(node) {
        return node;
    }
    visitLookaheadAssertion(node) {
        return node.update(this.visit(node.lookahead));
    }
    visitLexicalGoalAssertion(node) {
        return node.update(this.visit(node.symbol));
    }
    visitNoSymbolHereAssertion(node) {
        return node.update(this.visitEach(node.symbols));
    }
    visitConstraints(node) {
        return node.update(this.visitEach(node.elements));
    }
    visitProseAssertion(node) {
        return node.update(this.visitEach(node.fragments));
    }
    visitProseFragmentLiteral(node) {
        return node;
    }
    visitArgument(node) {
        return node.update(this.visit(node.name));
    }
    visitArgumentList(node) {
        return node.update(this.visitEach(node.elements));
    }
    visitNonterminal(node) {
        return node.update(this.visit(node.name), this.visit(node.argumentList));
    }
    visitTerminal(node) {
        return node.update(this.visit(node.literal), this.visit(node.questionToken));
    }
    visitProse(node) {
        return node.update(this.visitEach(node.fragments));
    }
    visitOneOfSymbol(node) {
        return node.update(this.visitEach(node.symbols));
    }
    visitSymbolSpan(node) {
        return node.update(this.visit(node.symbol), this.visit(node.next));
    }
    visitLinkReference(node) {
        return node;
    }
    visitRightHandSide(node) {
        return node.update(this.visit(node.constraints), this.visit(node.head), this.visit(node.reference));
    }
    visitRightHandSideList(node) {
        return node.update(this.visitEach(node.elements));
    }
    visitOneOfList(node) {
        return node.update(this.visitEach(node.terminals));
    }
    visitParameter(node) {
        return node.update(this.visit(node.name));
    }
    visitParameterList(node) {
        return node.update(this.visitEach(node.elements));
    }
    visitProduction(node) {
        return node.update(this.visit(node.name), this.visit(node.parameterList), this.visit(node.body));
    }
    visitImport(node) {
        return node;
    }
    visitDefine(node) {
        return node;
    }
    visitLine(node) {
        return node;
    }
    visitSourceFile(node) {
        return node.update(this.visitEach(node.elements));
    }
}
exports.NodeVisitor = NodeVisitor;
//# sourceMappingURL=visitor.js.map