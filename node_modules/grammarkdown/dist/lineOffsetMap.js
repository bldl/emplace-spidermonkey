"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineOffsetMap = exports.equateLineOffsets = exports.compareLineOffsets = void 0;
const core_1 = require("./core");
const regionMap_1 = require("./regionMap");
const types_1 = require("./types");
function compareSourceLines(a, b) {
    if (a === "default")
        return b === "default" ? 0 : -1;
    if (b === "default")
        return 1;
    return (0, core_1.compare)(a.file, b.file)
        || (0, core_1.compareNumbers)(a.line, b.line);
}
/* @internal */
function compareLineOffsets(a, b) {
    return (0, core_1.compareNumbers)(a.generatedLine, b.generatedLine)
        || compareSourceLines(a.sourceLine, b.sourceLine);
}
exports.compareLineOffsets = compareLineOffsets;
function equateSourceLines(a, b) {
    if (a === "default")
        return b === "default";
    if (b === "default")
        return false;
    return a.line === b.line
        && a.file === b.file;
}
/* @internal */
function equateLineOffsets(a, b) {
    return a.generatedLine === b.generatedLine
        && equateSourceLines(a.sourceLine, b.sourceLine);
}
exports.equateLineOffsets = equateLineOffsets;
class LineOffsetMap {
    /* @internal */
    addLineOffset(sourceFile, line, sourceLine) {
        const filename = typeof sourceFile === "string" ? sourceFile : sourceFile.filename;
        this.generatedFilesLineOffsets || (this.generatedFilesLineOffsets = new regionMap_1.RegionMap(equateSourceLines));
        this.generatedFilesLineOffsets.addRegion(sourceFile, line, sourceLine);
        // add reverse mapping
        this.sourceFilesLineOffsets || (this.sourceFilesLineOffsets = new regionMap_1.RegionMap(equateSourceLines));
        const reverseFilename = sourceLine === "default" || sourceLine.file === undefined ? filename : sourceLine.file;
        const reverseLine = sourceLine === "default" ? line : sourceLine.line;
        const reverseSourceLine = sourceLine === "default" ? "default" : { file: filename, line };
        this.sourceFilesLineOffsets.upsertRegion(reverseFilename, reverseLine, old => {
            if (reverseSourceLine === "default")
                return old !== null && old !== void 0 ? old : reverseSourceLine;
            return reverseSourceLine;
        });
    }
    /* @internal */
    findLineOffset(sourceFile, position) {
        var _a;
        const filename = typeof sourceFile === "string" ? sourceFile : sourceFile.filename;
        return (_a = this.generatedFilesLineOffsets) === null || _a === void 0 ? void 0 : _a.findRegion(filename, position.line);
    }
    /* @internal */
    findRawOffset(filename, position) {
        var _a;
        return (_a = this.sourceFilesLineOffsets) === null || _a === void 0 ? void 0 : _a.findRegion(filename, position.line);
    }
    /* @internal */
    copyFrom(other) {
        if (other.generatedFilesLineOffsets) {
            this.generatedFilesLineOffsets || (this.generatedFilesLineOffsets = new regionMap_1.RegionMap(equateSourceLines));
            this.generatedFilesLineOffsets.copyFrom(other.generatedFilesLineOffsets);
        }
    }
    /**
     * Gets the effective filename of a raw position within a source file, taking into account `@line` directives.
     */
    getEffectiveFilenameAtPosition(sourceFile, position) {
        const filename = typeof sourceFile === "string" ? sourceFile : sourceFile.filename;
        const lineOffset = this.findLineOffset(filename, position);
        if (lineOffset && lineOffset.value !== "default" && lineOffset.value.file !== undefined) {
            return lineOffset.value.file;
        }
        return filename;
    }
    /**
     * Gets the effective position of a raw position within a source file, taking into account `@line` directives.
     */
    getEffectivePosition(sourceFile, position) {
        const filename = typeof sourceFile === "string" ? sourceFile : sourceFile.filename;
        const lineOffset = this.findLineOffset(filename, position);
        if (lineOffset && lineOffset.value !== "default") {
            const diff = position.line - lineOffset.line;
            const sourceLine = lineOffset.value.line + diff;
            return types_1.Position.create(sourceLine, position.character);
        }
        return position;
    }
    /**
     * Gets the effective range of a raw range within a source file, taking into account `@line` directives.
     */
    getEffectiveRange(sourceFile, range) {
        const filename = typeof sourceFile === "string" ? sourceFile : sourceFile.filename;
        const start = this.getEffectivePosition(filename, range.start);
        const end = this.getEffectivePosition(filename, range.end);
        return start !== range.start || end !== range.end ? types_1.Range.create(start, end) : range;
    }
    getRawFilenameAtEffectivePosition(filename, position) {
        const lineOffset = this.findRawOffset(filename, position);
        if (lineOffset && lineOffset.value !== "default" && lineOffset.value.file !== undefined) {
            return lineOffset.value.file;
        }
        return filename;
    }
    getRawPositionFromEffectivePosition(filename, position) {
        const lineOffset = this.findRawOffset(filename, position);
        if (lineOffset && lineOffset.value !== "default") {
            const diff = position.line - lineOffset.line;
            const sourceLine = lineOffset.value.line + diff;
            return types_1.Position.create(sourceLine, position.character);
        }
        return position;
    }
    getRawRangeFromEffectiveRange(filename, range) {
        const start = this.getRawPositionFromEffectivePosition(filename, range.start);
        const end = this.getRawPositionFromEffectivePosition(filename, range.end);
        return start !== range.start || end !== range.end ? types_1.Range.create(start, end) : range;
    }
}
exports.LineOffsetMap = LineOffsetMap;
//# sourceMappingURL=lineOffsetMap.js.map