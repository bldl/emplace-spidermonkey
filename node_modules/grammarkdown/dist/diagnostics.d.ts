/*!
 * Copyright (c) 2020 Ron Buckton (rbuckton@chronicles.org)
 *
 * This file is licensed to you under the terms of the MIT License, found in the LICENSE file
 * in the root of this repository or package.
 */
import { Range, Position } from "./types";
import { SyntaxKind } from "./tokens";
import { Node, SourceFile } from "./nodes";
import { LineOffsetMap } from "./lineOffsetMap";
/** {@docCategory Check} */
export interface Diagnostic {
    code: number;
    message: string;
    warning?: boolean;
}
export { Diagnostics } from "./diagnostics.generated";
/** {@docCategory Check} */
export interface DiagnosticInfo {
    diagnosticIndex: number;
    code: number;
    message: string;
    messageArguments: any[] | undefined;
    warning: boolean;
    range: Range | undefined;
    sourceFile: SourceFile | undefined;
    filename: string | undefined;
    node: Node | undefined;
    pos: number;
    formattedMessage?: string;
}
/** {@docCategory Check} */
export declare class DiagnosticMessages {
    private diagnostics;
    private diagnosticsArguments;
    private diagnosticsPos;
    private diagnosticsLength;
    private diagnosticsNode;
    private detailedDiagnosticMessages;
    private simpleDiagnosticMessages;
    private sourceFiles;
    private sourceFilesDiagnosticOffset;
    private sortedAndDeduplicatedDiagnosticIndices;
    private lineOffsetMap;
    constructor(lineOffsetMap?: LineOffsetMap);
    get size(): number;
    copyFrom(other: DiagnosticMessages): void;
    setSourceFile(sourceFile: SourceFile): void;
    report(pos: number, message: Diagnostic, ...args: any[]): void;
    reportRange(pos: number, end: number, message: Diagnostic, ...args: any[]): void;
    reportNode(sourceFile: SourceFile | undefined, node: Node, message: Diagnostic, ...args: any[]): void;
    count(): number;
    getMessage(diagnosticIndex: number, options?: {
        detailed?: boolean;
        raw?: boolean;
    }): string;
    getDiagnostic(diagnosticIndex: number): Diagnostic | undefined;
    getDiagnosticInfos(options?: {
        formatMessage?: boolean;
        detailedMessage?: boolean;
        raw?: boolean;
    }): DiagnosticInfo[];
    getDiagnosticInfosForSourceFile(sourceFile: SourceFile, options?: {
        formatMessage?: boolean;
        detailedMessage?: boolean;
        raw?: boolean;
    }): DiagnosticInfo[];
    getDiagnosticInfo(diagnosticIndex: number, options?: {
        formatMessage?: boolean;
        detailedMessage?: boolean;
        raw?: boolean;
    }): DiagnosticInfo | undefined;
    getDiagnosticArguments(diagnosticIndex: number): any[] | undefined;
    getDiagnosticRange(diagnosticIndex: number, raw?: boolean): Range | undefined;
    getDiagnosticPosition(diagnosticIndex: number, raw?: boolean): Position | undefined;
    getDiagnosticNode(diagnosticIndex: number): Node | undefined;
    getDiagnosticSourceFile(diagnosticIndex: number): SourceFile | undefined;
    getDiagnosticFilename(diagnosticIndex: number, raw?: boolean): string | undefined;
    forEach(callback: (message: string, diagnosticIndex: number) => void): void;
    values(): Generator<DiagnosticInfo | undefined, void, unknown>;
    [Symbol.iterator](): Generator<DiagnosticInfo | undefined, void, unknown>;
    private getSortedAndDeduplicatedDiagnosticIndices;
    private sortDiagnostics;
    private compareDiagnostics;
    private deduplicateDiagnostics;
    private getDiagnosticPos;
    private getDiagnosticLength;
    private getDiagnosticCode;
    private getDiagnosticErrorLevel;
    private reportDiagnostic;
}
/** {@docCategory Check} */
export declare class NullDiagnosticMessages extends DiagnosticMessages {
    private static _instance;
    static get instance(): NullDiagnosticMessages;
    get size(): number;
    copyFrom(other: DiagnosticMessages): void;
    setSourceFile(sourceFile: SourceFile): void;
    report(pos: number, message: Diagnostic, ...args: any[]): void;
    reportNode(sourceFile: SourceFile | undefined, node: Node, message: Diagnostic, ...args: any[]): void;
}
/** {@docCategory Check} */
export declare class LineMap {
    private text;
    private lineStarts;
    constructor(text: string);
    get lineCount(): number;
    formatOffset(pos: number): string;
    offsetAt(position: Position): number;
    positionAt(offset: number): Position;
    getLine(line: number): LineInfo;
    private computeLineStarts;
}
export interface LineInfo {
    readonly line: number;
    readonly text: string;
    readonly range: Range;
    readonly rangeIncludingLineTerminator: Range;
}
export declare function formatString(format: string, args?: any[]): string;
export declare function formatString(format: string, ...args: any[]): string;
export declare function formatList(tokens: (SyntaxKind | string)[]): string;
