"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegionMap = void 0;
const core_1 = require("./core");
const sortedUniqueList_1 = require("./sortedUniqueList");
function compareRegions(a, b) {
    return (0, core_1.compare)(a.line, b.line);
}
function selectLine(a) {
    return a.line;
}
class RegionMap {
    constructor(equateValues) {
        this._equateRegions = (a, b) => a.line === b.line && equateValues(a.value, b.value);
    }
    /**
     * Adds a `Region` for a source file.
     * @param sourceFile The source file in which to add a region
     * @param line The line number of the region start
     * @param value The value for the region
     */
    addRegion(sourceFile, line, value) {
        var _a;
        (_a = this._sourceFileRegions) !== null && _a !== void 0 ? _a : (this._sourceFileRegions = new Map());
        const filename = typeof sourceFile === "string" ? sourceFile : sourceFile.filename;
        let regions = this._sourceFileRegions.get(filename);
        if (!regions)
            this._sourceFileRegions.set(filename, regions = new sortedUniqueList_1.SortedUniqueList(compareRegions, this._equateRegions));
        regions.push({ line, value });
    }
    /**
     * Adds or updates a `Region` for a source file.
     * @param sourceFile The source file in which to add a region
     * @param line The line number of the region start
     * @param value The value for the region
     */
    upsertRegion(sourceFile, line, upsert) {
        var _a;
        (_a = this._sourceFileRegions) !== null && _a !== void 0 ? _a : (this._sourceFileRegions = new Map());
        const filename = typeof sourceFile === "string" ? sourceFile : sourceFile.filename;
        let regions = this._sourceFileRegions.get(filename);
        if (!regions)
            this._sourceFileRegions.set(filename, regions = new sortedUniqueList_1.SortedUniqueList(compareRegions, this._equateRegions));
        const array = regions.toArray();
        let index = (0, core_1.binarySearchBy)(array, line, selectLine, core_1.compareNumbers);
        if (index >= 0 && index < array.length) {
            const region = array[index];
            regions.mutate((array) => {
                if (array[index] === region) {
                    array[index] = { line, value: upsert(region.value) };
                }
            });
        }
        else {
            regions.push({ line, value: upsert(undefined) });
        }
    }
    /**
     * Finds the nearest `Region` that starts at or prior to the provided `line`.
     * @param sourceFile The source file in which to find a region.
     * @param line The line number from which to start searching.
     */
    findRegion(sourceFile, line) {
        var _a, _b;
        const filename = typeof sourceFile === "string" ? sourceFile : sourceFile.filename;
        const regions = (_b = (_a = this._sourceFileRegions) === null || _a === void 0 ? void 0 : _a.get(filename)) === null || _b === void 0 ? void 0 : _b.toArray();
        if (!regions)
            return;
        let index = (0, core_1.binarySearchBy)(regions, line, selectLine, core_1.compareNumbers);
        if (index < 0)
            index = ~index - 1;
        if (index >= 0 && index < regions.length)
            return regions[index];
    }
    /**
     * Yields each `Region` that starts at or prior to the provided `line`, starting with the nearest `Region` first.
     * @param sourceFile The source file in which to find a region.
     * @param line The line number from which to start searching.
     */
    *regions(sourceFile, line) {
        var _a, _b;
        const filename = typeof sourceFile === "string" ? sourceFile : sourceFile.filename;
        const regions = (_b = (_a = this._sourceFileRegions) === null || _a === void 0 ? void 0 : _a.get(filename)) === null || _b === void 0 ? void 0 : _b.toArray();
        if (!regions)
            return;
        let index = (0, core_1.binarySearchBy)(regions, line, selectLine, core_1.compareNumbers);
        if (index < 0)
            index = ~index - 1;
        while (index >= 0 && index < regions.length) {
            yield regions[index];
            index--;
        }
    }
    copyFrom(other) {
        if (other._sourceFileRegions) {
            this._sourceFileRegions || (this._sourceFileRegions = new Map());
            for (const [filename, regions] of other._sourceFileRegions) {
                this._sourceFileRegions.set(filename, regions.clone());
            }
        }
    }
}
exports.RegionMap = RegionMap;
//# sourceMappingURL=regionMap.js.map