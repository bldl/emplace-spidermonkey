import type { Unlocated, LocationRange, Position, Token, Format, Node, TextNode, CommentNode, TagNode, FragmentNode, OrderedListNode, OrderedListItemNode, UnorderedListItemNode, FormatNode } from './node-types';
import { Tokenizer } from './tokenizer';
declare type ParseFragmentOpts = {
    inList?: boolean;
};
export declare class Parser {
    _t: Tokenizer;
    _posStack: Position[];
    constructor(tokenizer: Tokenizer);
    static parseAlgorithm(str: string): {
        name: "algorithm";
        contents: OrderedListNode;
    } & {
        location: LocationRange;
    };
    static parseFragment(str: string): FragmentNode[];
    parseAlgorithm(): {
        name: "algorithm";
        contents: OrderedListNode;
    } & {
        location: LocationRange;
    };
    parseList(): (Pick<OrderedListNode, "contents" | "name" | "indent" | "start"> & {
        location: LocationRange;
    }) | (Pick<import("./node-types").UnorderedListNode, "contents" | "name" | "indent"> & {
        location: LocationRange;
    });
    parseListItem(kind: 'ol', indent: number): OrderedListItemNode;
    parseListItem(kind: 'ul', indent: number): UnorderedListItemNode;
    parseFragment(opts: ParseFragmentOpts): FragmentNode[];
    parseFragment(opts: ParseFragmentOpts, closingFormatKind: Format): (TextNode | CommentNode | TagNode)[];
    parseText(opts: ParseFragmentOpts, closingFormatKind: Format | undefined): ({
        name: "text";
        contents: string;
    } & {
        location: LocationRange;
    }) | null;
    parseFormat(format: Format, opts: ParseFragmentOpts): (TextNode | CommentNode | TagNode | FormatNode)[];
    pushPos(): void;
    popPos(): Position | undefined;
    getPos(node?: Node | Token): Position;
    getEnd(node: Node | Token): Position;
    finish<T extends Unlocated<Node>>(node: T, start?: Position, end?: Position): T & {
        location: LocationRange;
    };
}
export {};
