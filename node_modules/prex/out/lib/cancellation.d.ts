/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Licensed under the Apache License, Version 2.0.

See LICENSE file in the project root for details.
***************************************************************************** */
import { Cancelable, CancelableSource, CancelSignal } from "@esfx/cancelable";
import { Disposable } from "@esfx/disposable";
/**
 * Signals a CancellationToken that it should be canceled.
 */
export declare class CancellationTokenSource implements CancelableSource {
    private _state;
    private _token;
    private _registrations;
    private _linkingRegistrations;
    /**
     * Initializes a new instance of a CancellationTokenSource.
     *
     * @param linkedTokens An optional iterable of tokens to which to link this source.
     */
    constructor(linkedTokens?: Iterable<CancellationToken | Cancelable>);
    /**
     * Gets a CancellationToken linked to this source.
     */
    get token(): CancellationToken;
    /**
     * Cancels the source, evaluating any registered callbacks. If any callback raises an exception,
     * the exception is propagated to a host specific unhanedle exception mechanism.
     */
    cancel(): void;
    /**
     * Closes the source, preventing the possibility of future cancellation.
     */
    close(): void;
    /**
     * Executes the provided callback.
     *
     * @param callback The callback to execute.
     */
    private _executeCallback;
    /**
     * Unlinks the source from any linked tokens.
     */
    private _unlink;
    [Cancelable.cancelSignal](): Cancelable & CancelSignal;
    [CancelableSource.cancel](): void;
}
/**
 * Propagates notifications that operations should be canceled.
 */
export declare class CancellationToken implements Cancelable {
    /**
     * A token which will never be canceled.
     */
    static readonly none: CancellationToken;
    /**
     * A token that is already canceled.
     */
    static readonly canceled: CancellationToken;
    private _source;
    /**
     * Gets a value indicating whether cancellation has been requested.
     */
    get cancellationRequested(): boolean;
    /**
     * Gets a value indicating whether the underlying source can be canceled.
     */
    get canBeCanceled(): boolean;
    /**
     * Adapts a CancellationToken-like primitive from a different library.
     */
    static from(cancelable: CancellationToken | VSCodeCancellationTokenLike | AbortSignalLike | Cancelable): CancellationToken;
    /**
     * Returns a CancellationToken that becomes canceled when **any** of the provided tokens are canceled.
     * @param tokens An iterable of CancellationToken objects.
     */
    static race(tokens: Iterable<CancellationToken | Cancelable>): CancellationToken;
    /**
     * Returns a CancellationToken that becomes canceled when **all** of the provided tokens are canceled.
     * @param tokens An iterable of CancellationToken objects.
     */
    static all(tokens: Iterable<CancellationToken | Cancelable>): CancellationToken;
    /**
     * Throws a CancelError if cancellation has been requested.
     */
    throwIfCancellationRequested(): void;
    /**
     * Registers a callback to execute when cancellation is requested.
     *
     * @param callback The callback to register.
     */
    register(callback: () => void): CancellationTokenRegistration;
    [Cancelable.cancelSignal](): Cancelable & CancelSignal;
}
/**
 * An error thrown when an operation is canceled.
 */
export declare class CancelError extends Error {
    constructor(message?: string);
}
/**
 * An object used to unregister a callback registered to a CancellationToken.
 */
export interface CancellationTokenRegistration extends Disposable {
    /**
     * Unregisters the callback
     */
    unregister(): void;
}
/**
 * Describes a foreign cancellation primitive similar to the one provided by `vscode` for extensions.
 */
export interface VSCodeCancellationTokenLike {
    readonly isCancellationRequested: boolean;
    onCancellationRequested(listener: () => any): {
        dispose(): any;
    };
}
/**
 * Describes a foreign cancellation primitive similar to the one used by the DOM.
 */
export interface AbortSignalLike {
    readonly aborted: boolean;
    addEventListener(type: "abort", callback: () => any): any;
}
/**
 * An object that provides a CancellationToken that becomes cancelled when **all** of its
 * containing tokens are canceled. This is similar to `CancellationToken.all`, except that you are
 * able to add additional tokens.
 */
export declare class CancellationTokenCountdown {
    private _addedCount;
    private _signaledCount;
    private _canBeSignaled;
    private _source;
    private _registrations;
    constructor(iterable?: Iterable<CancellationToken | Cancelable>);
    /**
     * Gets the number of tokens added to the countdown.
     */
    get addedCount(): number;
    /**
     * Gets the number of tokens that have not yet been canceled.
     */
    get remainingCount(): number;
    /**
     * Gets the CancellationToken for the countdown.
     */
    get token(): CancellationToken;
    /**
     * Adds a CancellationToken to the countdown.
     */
    add(token: CancellationToken | Cancelable): this;
    private _checkSignalState;
}
